---
layout: page
title: "PC-SIG Diskette Library (Disk #215)"
permalink: /software/pcx86/sw/misc/pcsig/0001-0999/DISK0215/
machines:
  - id: ibm5150
    type: pcx86
    config: /machines/pcx86/ibm/5150/cga/256kb/machine.xml
    diskettes: /machines/pcx86/diskettes.json,/disks/pcsigdisks/pcx86/diskettes.json
    autoGen: true
    autoMount:
      B: "PC-SIG Library Disk #0215"
    autoType: $date\r$time\rB:\rDIR\r
---

{% include machine.html id="ibm5150" %}

{% comment %}info_begin{% endcomment %}

## Information about "DATA BASE OF STEEL 2 OF 4 (214,267,268)"

    This is the first volume of Potomac Engineering's database, spreadsheet
    and expert system offerings, all grouped under the title "... of
    Steel".  The first two disks contain the Database Management System
    which includes Accounting, Payroll, Inventory, and A/R Applications
    Programmable, Relational.  The documentation for the whole system is on
    Disk No 215.
    
    The Spreadsheet (No 267) includes 21 ways to calculate numbers or write
    your own subroutine.  It is written in BASIC for easy modification, and
    a compiled version is available.
    
    The Expert System (No 268) provides for inference engines, designing
    your own expert systems, and intelligent search patterns.  The entire
    system is menu driven, so all the options are displayed on the screen.
    
    Features:
    
    ~ Written in BASIC for easy modification
    ~ Compiled version provided (192k)
    ~ Sample checkbook application
    ~ Automatic recalculation
    ~ Bar charts
    ~ Full cursor control
    ~ Report generator
    ~ Customizable screens
    ~ ASCII output
    ~ Tax tables
    ~ Create subfiles
    ~ Sort on 3 fields
    ~ 3 files open simultaneously
    ~ Global field changes
    ~ Transfer data between files
    ~ Inference engine
    ~ Design expert systems
    ~ Assigns probability with rules
    ~ Intellignet search pattern with manual override
    ~ Detects contradictory evidence
    ~ Explanation of reasoning
    
    System Requirements:  Two disk drives (Hard disk recommended)
    
    How to Start: Consult the README file for documentation and
    directions. To run the BASIC programs follow the GETTING STARTED
    instructions for your configuration.
    
    Suggested Registration:  $20.00
    
    File Descriptions:
    
    The First Disk Contains:
    -------- ---  Database of Steel - Source Code
    SCAN     BAS  Database extract and select program
    MAIN     BAS  Main database program
    CHANGE   BAS  Global database change and replacement
    FORM     BAS  Report format program
    TRANSFER BAS  Transfer data from one file to another
    CFILE    BAS  Creates (defines) database file
    SORT     BAS  Sorts database
    CTRANSFE BAS  Customizes transfers between files
    CINPUT   BAS  Sets up new data entry for the file
    CLIMITS  BAS  Sets range limts for numeric fields
    CFORM    BAS  Creates print forms
    TESTASCI BAS  Reads file created from above and display it
    ASCII    BAS  Convert from random access format to ASCII
    CSCREEN  BAS  Sets up screen display for record
    CREAL    BAS  Realtime transfers between files
    READ     ME   Descriptions of files on disk
    
    The Second Disk Contains:
    READ     ME   Descriptions of files on disk
    -------- ---  Database of Steel - sample programs and files, doc
    MASTER   TXT  Manual (WordStar format - 153K)
    REMARKS4 BAS  Program remarks
    REMARKS3 BAS  Program remarks
    REMARKS2 BAS  Program remarks
    REMARKS1 BAS  Program remarks
    PRINTMAN BAS  Procedure to print the manual
    ???      OBJ  Part of Database of Steel
    ???      BAS  Part of Database of Steel
    ???           Various data files for Database of Steel
    
    The Third Disk Contains:
    -------- ---  Spreadsheet of Steel and Compiled Database Program
    READ     ME   Description of files on this disk
    REMARKST BAS  Sort remarks
    MAIN     EXE  Compiled database program
    CHECK         Sample spreadsheet
    TAX           Sample spreadsheet
    SORTINT  BAS  Sort source for database
    SORT     BAS  Sort source for database
    SS       EXE  Compiled spreadsheet
    SSREMARK BAS  Spreadsheet remarks
    SS       BAS  Spreadsheet source
    SORTSTR  BAS  Sort source for database
    
    The Fourth Disk Contains:
    -------- ---  Expert System of Steel
    EXPERT   BAS  Source code for expert system
    EXPERT   EXE  Compiled program for expert system
    REM      BAS  Remarks for source program  (33K)
    READ     ME   Description of files on this disk
    FORM     EXE  Compiled program for database
    SCAN     EXE  Compiled program for database
    TEMP     BAS  Part of expert system disk
    CLS      OBJ  Part of expert system disk
    ???           Sample program for Database of Steel
{% comment %}info_end{% endcomment %}

{% comment %}samples_begin{% endcomment %}

## PRINTMAN.BAS

```bas
5 CLS
10 PRINT "      This program prints the manual on paper "
20 PRINT ""
30 PRINT " MAKE SURE YOU PRINTER IS ON WITH 50 PAGES OF PAPER READY"
40 PRINT ""
45 PRINT "   PUT THE DISK MARKED MANUAL IN THE DEFAULT DISK DRIVE "
50 PRINT "              Press any key to continue "
55 PRINT ""
60 IF INKEY$ = "" THEN 60
70 INPUT " ARE YOU USING IBM BASIC ? (Y/N return) ";  I$
80 IF I$ = "y" OR I$ = "Y" OR I$ = "N" OR I$ = "n" THEN 100 ELSE 70
90 LPRINT " "
100 OPEN "R",#1,"MASTER.TXT",10
110 FIELD #1,10 AS AT$
200 REM
230 FOR T = 1 TO 20000
240 GET #1,T 
242 FOR T2 = 1 TO 10
244 A$ = MID$(AT$,T2,1)
300 C = ASC(A$)
310 IF C = 10 AND ( I$ = "Y" OR I$ = "y") THEN 580
400 IF C <= 127 THEN LPRINT A$;
450 IF C > 127 THEN LPRINT CHR$(C-128);
580 NEXT T2
590 NEXT T
620 LPRINT ""
9000 END
```

## PRTEXTRA.BAS

```bas
5 CLS
10 PRINT "    This program prints the EXTRA DOCUMENTATION on paper"
20 PRINT ""
30 PRINT " MAKE SURE YOU PRINTER IS ON WITH 3  PAGES OF PAPER READY"
40 PRINT ""
45 PRINT "   PUT THE DISK MARKED REMARKS IN THE DEFAULT DISK DRIVE "
50 PRINT "          Press any key to start printing."
60 IF INKEY$ = "" THEN 60
100 OPEN "R",#1,"EXTRA",10
110 FIELD #1,10 AS AT$
200 REM
230 FOR T = 1 TO 10000
240 GET #1,T 
242 FOR T2 = 1 TO 10
244 A$ = MID$(AT$,T2,1)
300 C = ASC(A$)
400 IF C <= 127 THEN LPRINT A$;
450 IF C > 127 THEN LPRINT CHR$(C-128);
580 NEXT T2
590 NEXT T
620 LPRINT ""
9000 END
```

## REMARKS1.BAS

```bas
2 PRINT FRE(0) / PRINTS MEMORY AVAILABLE
3 DEFDBL X  / VARIABLES STARTING WITH X ARE DOUBLE PRECISION
4 DEFINT A-W,Y-Z / ALL OTHER VARIABLES ARE INTEGERS
5 DIM F$(15),FLDN$(15,28),FTY(15,28),FL(15,28),IOPT(28)
6 DIM PROMPT$(28),IFN(28),IFLD(28),IRNFLD(28),NOS(28),ADDFLD(28,6)
7 DIM SUBX(28),SUBY(28),MULX(28),MULY(28)
8 DIM XKEY(28),YKEY(28),CMOPT(28),MAXMIN(28,6)
9 DIM KC(28),CFLD(28)             
10 DIM X$(28),Y$(28)
13 DIM L(15),NREC(15),Z$(28),KT(28)
14 DIM X(28),CK$(28),SN$(28)
16 DIM KEYLIST(15,28),L$(10,50),LEND(28),CL(28)
18 DIM SU%(28),S!(10)
20 DIM XL(40)
21 DIM TX(6,28)
25 DIM S#(28)
26 DIM MAX(10),Z%(10)
30 DIM GFLG(28)
35 DIM K$(80)
40 DIM FS(30),PP(30),MS(30),MIND#(30),MAXD#(30),TAX#(30),PCT!(30),OVR#(30)
42 DIM MAXK(10)
44 DIM SCRN(40),LE(28),CE(28),LEK(28),CEK(28),SW$(18)
46 DIM REALFLG(28)
50 DIM SUMF(28),SUM#(28)
52 DIM SHOW(30),MAXC#(30),MINC#(30)
54 DIM MAXC(28),MINC(28),MFLG(28)
61 CH = 29 / CH IS THE ASCII CODE THAT MOVES CURSER BACK ONE SPACE
62 GOSUB 50000 / PRINT INTRO ON SCREEN
63 GOSUB 16800 / HARD DISK OPTION 
65 GOSUB 27000 / READ CUSTOM SCREEN FLAG
80 GOSUB 10000 / READ FFILE (FILE DESCRIPTION)
90 GOSUB 29000 / READ LIMITS FLAG
95 GOSUB 60000 / READ REALTIME DATA FLAG OPTION
100 REM
400 GOSUB 13000 / CLEAR SCREEN
402 IF KD < 5 THEN GOSUB 11000 / READ KEYLIST IF NOT ALREADY IN MEMORY
403 ROPEN = 0 / FLAG, REALTIME TRANSFER FILE IS CLOSED
404 GOSUB 13000 / CLEAR SCREEN
406 TWOOPEN = 0 / FLAG, FILE TO GET DATA FROM IS CLOSED
410 PRINT "******  INPUT AND OUTPUT OPTIONS  --  WHAT FILE DO YOU WANT:  *****"
420 PRINT ""
425 PRINT " 0  - *** EXIT THE PROGRAM ***"
430 FOR I = 1 TO MAXF / STARTS LOOP PRINTING FILE NAMES
440 PRINT I;TAB(5) " - ";F$(I) / PRINTS FILE NUMBER AND NAME
450 NEXT I / END LOOP PRINTING FILE NAME
460 PRINT ""
470 PRINT "***** ENTER THE NUMBER OF THE FILE YOU WANT THEN PRESS RETURN *****"
475 GOSUB 14000 / INPUT INTEGER LESS THEN 100
477 IF DT# < 0 OR DT#>MAXF  GOTO 475 / CHECKS THAT OPTION NUMBER IS IN LIMITS
480 A = DT# / SETS A = TO VALUE RETURNED FROM 14000 SUBROUTINE
482 IF A = 0 GOTO 51000 / GOTO END PROGRAM
483 GOSUB 13000 / CLEAR SCREEN
484 PRINT "FILE : "; F$(A) /PRINTS FILE NAME
485 GOSUB 2300 / GETS DISK DRIVE NUMBER
490 GOSUB 2500 / OPENS FILE AS FILE NUMBER 1
491 CSCR = 2 / FLAG, DO NOT USE CUSTOM SCREEN
492 IF SCRN(A) <> 0 THEN GOSUB 28000 ELSE RPT = 0 / IF SCREEN FLAG  YES THEN READ CUSTOM SCREEN DESCRIPTION ELSE REPEATING OPTION = 0
493 IF MFLG(A) = 2 THEN GOSUB 29070 / IF THERE ARE LIMITS THEN READ THE LIMITS
494 GOSUB 40020 / READ INPUT OPTIONS FOR THIS FILE
495 IF REALFLG(A) = 2 THEN GOSUB 60070 / IF REALTIME TRANSFERS THEN READ REALTIME DESCRIPTION
500 IF REALFLG(A) = 2 THEN GOSUB 60200 / IF REALTIME TRANSFERS THEN OPEN REALTIME TRANSFER FILE
530 GOTO 3000 / GOTO FILE OPTIONS
1905 MATCH = 1 / INITIALIZE 
2300 REM DISK  SELECTION
2302 IF HDISK = 2 THEN GOSUB 13000 / IF USING HARDDISK OPTION THE CLEAR SCREEN
2303 IF HDISK = 2 THEN GOTO 2360 / IF USING HARD DISK THEN USE DEFAULT DRIVE
2304 PRINT ""
2305 PRINT "************  WHICH DISK DRIVE IS THE FILE ON  **************"
2310 PRINT ""
2312 PRINT "                 0 - BACK TO CHOISE OF FILES"
2315 PRINT "                 1 - DISK DRIVE A"
2320 PRINT "                 2 - DISK DRIVE B"
2325 PRINT "                 3 - DISK DRIVE C"
2330 PRINT "                 4 - DISK DRIVE D"
2335 PRINT ""
2340 PRINT "***********  ENTER THE NUMBER THEN PRESS RETURN  ************"
2345 GOSUB 14000 / INPUT INTEGER LESS THEN 100 SUBROUTINE
2347 IF DT# < 0 OR DT#>4 GOTO 2345 / IF OPTION OUT OF RANGE THEN REPROMPT
2350 T = DT#  / DT# IS RETURNED FROM 14000
2352 IF T = 0 THEN 100 / TO CHOICE OF FILES
2355 ON T GOTO 2360,2370,2380,2390 / ON DISK DRIVE NUMBER GOTO
2360 T$ = F$(A) / USE DEFAULT DRIVE
2365 GOTO 2490
2370 T$ = "B:"+F$(A) / USE DRIVE B
2375 GOTO 2490
2380 T$ = "C:"+F$(A) / USE DRIVE C
2385 GOTO 2490
2390 T$ = "D:"+F$(A) / USE DRIVE D
2490 RETURN
2500 REM OPEN FILE 
2503 CLOSE #1 / CLOSE FILE TO PREVENT ERRORS
2505 OPEN "R",#1,T$,L(A) / OPENS RANDOM ACCESS FILE AS FILE #1, FILE NAME = T$, WITH LENGTH L
2507 D = 0
2510 FOR T = 1 TO NREC(A) / START FIELDING LOOP,NREC(A) IS THE NUMBER OF FIELDS IN THE FILE
2520 FIELD #1,D AS DY$,FL(A,T) AS X$(T) / DY$ IS A DUMMY, FL(A,T) IS THE LENTH OF THE FIELD, X$(T) IS THE T'TH FIELD
2530 D = D + FL(A,T) / LENGTH OF THE DUMMY VARIABLE
2540 NEXT T / END FIELDING LOOP
2543 GOSUB 7800 / GET THE MAXIMUM RECORD NUMBER
2545 RETURN
2550 REM OPEN SECOND FILE / SAME AS THE ABOVE SUBROUTINE EXCEPT THAT FILE 2 IS OPENED, 
2553 CLOSE #2 / CLOSE FILE TO PREVENT ERRORS
2555 OPEN "R",#2,T$,L(B) / OPEN RANDOM ACCESS FILE AS FILE #2, FILE NAME T$, WITH LENGTH L
2557 D = 0
2560 FOR T = 1 TO NREC(B) / START FIELDING LOOP, NREC(A) IS THE NUMBER OF FIELDS IN THE FILE
2565 FIELD #2,D AS DY$,FL(B,T) AS Y$(T) / DY$ IS A DUMMY, FL(A,T) IS THE LENGTH OF THE FIELD
2570 D = D + FL(B,T) / LENGTH OF THE DUMMY VARIABLE
2575 NEXT T
2578 RETURN
2580 REM OPEN THIRD FILE / SAME AS 2500 SUBROUTINE EXCPT THAT FILE 3 IS OPENED
2581 CLOSE #3 / CLOSE THIRD FILE TO PREVENT ERRORS
2584 OPEN "R",#3,T$,L(C) / OPEN RANDOM ACCESS FILE
2586 D = 0 / INITIALIZE TO 0
2588 FOR T = 1 TO NREC(C) / START FIELDING LOOP NREC(A) IS THE NUMBER OF FIELDS IN THE FILE
2590 FIELD #3,D AS DY$,FL(C,T) AS Z$(T) / Z$(T) = T'TH FIELD IN THIRD FILE
2592 D = D + FL(C,T) / LENGTH OF THE DUMMY VARIABLE
2594 NEXT T
2596 RETURN
3000 REM SECOND MENU 
3010 GOSUB 13000 / CLEAR SCREEN
3011 SFLG = 0 / INITIALIZE SEARCH FLAG TO 0
3012 PRINT "FILE : ";F$(A);TAB(57)"MAXIMUM RECORD :";MRN / PRINTS FILE NAME AND MAXIMUM RECORD NUMBER
3015 CALFLG = 0 / INITIALIZE RECALCULATE FLAG TO 0
3020 PRINT "*******************  WHAT DO YOU WANT TO DO WITH THE FILE  *******************"
3030 PRINT ""
3035 PRINT " 0 - CHANGE FILES  "
3040 PRINT " 1 - READ A SPECIFIC RECORD"
3050 PRINT " 2 - PRINT ON PAPER ALL OR SEVERAL SEQUENTIAL RECORDS"
3060 PRINT " 3 - SCAN SEVERAL RECORDS IN A FILE"
3070 PRINT " 4 - SEARCH A FILE"  
3080 PRINT " 5 - NEW ENTRY"
3090 PRINT " 6 - SEARCH A SORTED FILE"
3202 PRINT " 7 - RECALCULATE ALL THE RECORDS IN THE FILE"
3207 PRINT ""
3210 PRINT "*************  ENTER THE NUMBER OF THE OPTION THEN PRESS ENTER  ***************"
3212 SPRT = 5 / SURPRESS PRINTING AFTER OPTION IS ENTERED
3215 GOSUB 14000 / INPUT INTERGER < 100 SUBROUTINE
3218 IF DT# < 0 OR DT#>7 GOTO 3215 / IF OPTION OUR OF RANGE THEN REPROMPT
3220 N = DT# / DT# IS RETURNED FROM 14000
3225 IF N = 0 THEN CLOSE / IF CHANGING FILES THEN CLOSE ALL FILES
3227 IF N = 0 THEN GOTO 400 / IF CHANGING FILES BACK TO CHOISE OF FILE
3230 ON N GOTO 8000,5000,4000,18000,3700,17000,47000 / ON OPTION GOTO
3600 GOTO 18000 / SEARCH A FILE
3700 GOSUB 13000 / CLEAR SCREEN
3720 GOTO 7000 / GOTO NEW ENTRY
4000 REM SCAN ALL RECORDS
4005 GOSUB 13000 / CLEAR SCREEN
4007 GOSUB 7800 / GET MAXIMUM RECORD NUMBER
4008 GOSUB 4100 / INPUT FIELDS TO DISPLAY SUBROUTINE
4009 GOSUB 13000 / CLEAR SCREEN
4010 PRINT "************  SCAN ALL SEQUENTIAL RECORDS SUBPROGRAM  ************"
4011 PRINT ""
4012 PRINT "               WHAT RECORD DO YOU WANT TO START AT ?  "       
4013 PRINT ""
4014 PRINT "                Enter zero to return to file options "
4015 PRINT ""
4016 PRINT "***********  ENTER THE RECORD NUMBER THEN PRESS RETURN  ***********"
4018 GOSUB 14100 / INPUT INTEGER SUBROUTINE
4020 RN = DT# / RECORD NUMBER = VALUE RETURNED BY THE ABOVE SUBROUTINE
4022 IF RN = 0 THEN GOTO 3010 / IF OPTION = 0 THEN BACK TO FILE OPTIONS
4032 IF INKEY$ <> "" GOTO 4600 / IF ANY KEY IS PRESSED THEN PAUSE SUBROUTINE
4035 IF RN > MRN GOTO 26000 / IF RECORD NUMBER > MAXIMUM RECORD NUMBER THEN TO END OF FILE SUBROUTINE
4040 GET #1,RN / GET RECORD NUMBER RN FROM DISK
4050 GOSUB 4300 / PRINT THE FIELDS 
4060 RN = RN + 1 / INCREMENT RECORD NUMBER
4070 GOTO 4032 / DO IT AGAIN
4100 REM ****  GET FIELDS TO DISPLAY
4110 FOR T = 1 TO NREC(A) / FOR EACH FIELD ASK IF YOU WANT IT DISPLAYED
4120 GOSUB 13000 / CLEAR SCREEEN
4124 PRINT "*******************  SCAN SUBROUTINE  **********************"
4126 PRINT ""
4130 PRINT "FIELD NUMBER : ";T;" - "; FLDN$(A,T) / PRINTS FIELD NAME
4140 PRINT ""
4150 PRINT "*****  DO YOU WANT THIS FIELD DISPALYED WHILE SCANNING  *****"
4160 PRINT ""
4170 PRINT "             1 - NO, Do not show this field "
4180 PRINT "             2 - YES, Show this field "
4190 PRINT ""
4200 PRINT "************  Enter the number then press return  ***********"
4210 GOSUB 14000 / INPUT INTEGER < 100 SUBROUTINE
4220 IF DT# < 1 OR DT# > 2 THEN 4210 / IF OPTION OUT OF LIMITS THEN REPROMPT
4230 SHOW(T) = DT# / SHOW(T) IS THE OPTION CHOSEN FOR THE T'TH VARIABLE
4240 NEXT T / END LOOP
4250 RETURN
4300 REM ****  PRINT FIELDS 
4305 PRINT "RECORD NUMBER ";RN
4310 FOR Q = 1 TO NREC(A) / START LOOP PRINTING OUT THE FIELDS
4320 IF SHOW(Q) = 2 THEN GOSUB 12030 / IF THE FIELD IS TO BE PRINTED THEN GOTO THE PRINT SUBROUTINE
4330 NEXT Q / END LOOP PRINTING OUT THE FIELDS
4340 RETURN
4600 REM 
4604 PRINT "******************  PAUSE SUBROUTINE  **********************"
4608 PRINT " 1 - CONTINUE SCANING "
4610 PRINT " 0 - BACK TO FILE OPTIONS "
4625 PRINT "***********  ENTER THE NUMBER THEN PRESS RETURN  ***********"    
4628 GOSUB 14000 / INPUT INTEGER < 100 SUBROUTINE
4635 IF DT# = 0 THEN GOTO 3010 / IF OPTION = 0 THEN BACK TO FILE OPTIONS
4640 GOTO 4040 / CONTINE SCANNING
5000 REM 
5005 GOSUB 13000 / CLEAR SCREEN
5010 PRINT "************  PRINT ON PAPER ALL SEQUENTIAL RECORDS  *************"
5011 PRINT ""
5012 PRINT "          WHAT RECORD DO YOU WANT TO START PRINTING AT ?"
5013 PRINT ""
5014 PRINT "               Enter zero to return to file options "
5015 PRINT ""
5016 PRINT "***********  ENTER THE RECORD NUMBER THEN PRESS RETURN  **********"
5018 GOSUB 14100 / INPUT INTEGER SUBROUTINE 
5020 RN = DT# / RECORD NUMBER EQUALS VALUE RETURNED FROM THE INPUT SUBROUTINE
5021 IF RN = 0 GOTO 3010 / IF OPTION = 0 THEN BACK TO FILE OPTIONS
5022 PRINT "**************  DO YOU WANT THIS RECORD PRINTED IN  **************"
5023 PRINT "                   1 - EXPANDED FORM "
5024 PRINT "                   2 - CONDENSED FORM "
5025 PRINT "**************  ENTER THE NUMBER THEN PRESS RETURN  **************"
5026 GOSUB 14000 / INPUT INTEGER SUBROUTINE 
5027 IF DT# < 1 OR DT#>2 GOTO 5026 / IF OPTION OUT OF RANGE THE REPROMPT
5030 PFLG = DT# / PRINT FLAG = VALUE RETURNED FROM INPUT SUBROUTINE
5031 IF PFLG = 2 THEN GOSUB 12880 / IF PRINT IN CONDENSED FORM THEN ASK FOR NUMBER OF COLUMS ON PRINTER
5032 IF PFLG = 2 THEN GOSUB 12900 / IF PRINT IN CONDENSED FORM THEN COMPUTE WHERE TO PRINT FIELDS
5033 GOSUB 16000 / TURN YOUR PRINTER ON PROMPT
5036 REM
5038 IF INKEY$ <> "" GOTO 5600 / GOTO PAUSE SUBROUTINE IF ANY KEY IS PRESSED
5039 IF RN > MRN GOTO 26000 / IF RECORD NUMBER EXCEEDS MAXIMUM THE GOTO END OF FILE SUBROUTINE
5040 REM
5041 GET #1,RN / GET RECORD NUMBER RN
5050 IF PFLG = 1 THEN GOSUB 12200 / IF PRINT IN EXPANDED FORM THEN PRINT USING 12200 SUBROUTINE
5060 IF PFLG = 2 THEN GOSUB 12500 / IF PRINT IN CONDENSED FORM THEN PRINT USING 12500 SUBROUTINE
5510 RN = RN + 1 / INCREMENT RECORD NUMBER
5520 GOTO 5036 / START OVER AND PRINT NEXT RECORD
5600 REM 
5602 GOSUB 13000 / CLEAR SCREEN
5604 PRINT "******************  PAUSE SUBROUTINE  **********************"
5606 PRINT ""
5608 PRINT " 1 - CONTINUE PRINTING "
5610 PRINT " 0 - BACK TO FILE OPTIONS"
5620 PRINT ""
5625 PRINT "***********  ENTER THE NUMBER THEN PRESS RETURN  ***********"    
5628 GOSUB 14000 / INPUT INTEGER < 100 SUBROUTINE
5630 IF DT# = 0  THEN GOTO 3010 / IF OPTION 0 THEN BACK TO FILE OPTIONS
5640 GOTO 5040 / CONTINUE PRINTING
5725 REM
6000 REM 
7000 REM / START ON NEW RECORD ENTERY
7010 GOSUB 13000 / CLEAR SCREEN
7012 PRINT ""
7014 PRINT "FILE NAME: ";F$(A)
7020 PRINT "********************  NEW RECORD ENTRY  ********************"
7022 PRINT ""
7024 PRINT "*******************  WHAT RECORD NUMBER ?  *****************"
7030 PRINT ""
7031 GOSUB 7800
7032 PRINT "**********  Enter zero to return to file options  **********"
7033 PRINT ""
7034 PRINT "---- MAXIMUM RECORD NUMBER  CURRENTLY = ";MRN
7035 PRINT "---- ENTER A NUMBER FROM 1 TO ";MRN +1        
7036 PRINT ""
7038 PRINT "********  ENTER THE RECORD NUMBER THEN PRESS RETURN  *******"
7040 GOSUB 14100 / INPUT INTEGER SUBROUTINE
7042 IF DT# <0 OR DT# >(MRN +1) GOTO 7040 / IF OPTION OUT OF RANGE REPROMPT
7045 RN = DT# / RECORD NUMBER = VALUE RETURED FROM INPUT SUBROUTINE
7046 GOSUB 13000 / CLEAR SCREEN
7048 IF RN = 0 GOTO 3010 / IF OPTION 0 THEN RETURN TO FILE OPTIONS
7200 GOSUB 40000 / CONTINUE WITH NEW ENTRY
7205 IF RN > MRN THEN MRN = RN / IF RECORD NUMBER > MAXIMUM RECORD NUMBER THEN  LET MAXIMUM RECORD NUMBER = THE RECORD NUMBER
7210 GOTO 7010 / BACK  TO NEW ENTRY
7800 MRN = LOF(1)/ L(A) / COMPUTES MAXIMUM RECORD NUMBER OF FILE 1
7805 REM MRN = INT(MRN)
7810 RETURN
7900 REM ***** LOF
7910 MRN2 = LOF(3)/82 / MAXIMUM RECORD NUMBER OF TAX FILE
7920 RETURN
7950 REM ******* LOF
7960 MRNS = LOF(2)/L(B) / MAXIMUM RECORD NUMBER OF SECOND FILE
7970 RETURN
8000 REM 
8010 GOSUB 13000 / CLEAR SCREEN
8020 PRINT "********************  READ A SINGLE RECORD  *******************"
8030 PRINT ""
8040 PRINT "FILE NAME: ";F$(A)
8042 PRINT ""
8043 PRINT "MINIMUM RECORD NUMBER : 1   MAXIMIM RECORD NUMBER : ";MRN
8044 PRINT ""
8045 PRINT "******* ENTER THE NUMBER OF THE RECORD THEN PRESS RETURN ******"
8046 PRINT ""
8048 PRINT "***********  ENTER ZERO TO RETURN TO FILE OPTIONS  ************"
8049 GOSUB 7800 / GET MAXIMUM RECORD NUMBER
8050 GOSUB 14100 / INPUT INTEGER SUBROUTINE
8052 RN = DT# / RECORD NUMBER = VALUE RETURED FROM INPUT SUBROUTINE
8057 IF RN = 0 THEN GOTO 3010 / IF OPTION 0 BACK TO FILE OPTIONS
8058 GOSUB 13000 / CLEAR SCREEN
8059 IF RN > MRN GOTO 26800 / IF RECORD NUMBER EXCEEDS MAXIMUM RECORD NUMBER THE GOTO END OF FILE SUBROUTINE
8060 GET #1,RN / GET RECORD NUMBER RN
8500 GOSUB 12000 / PRINT THE RECORD ON THE SCREEN SUBROUTINE
8510 LI = 20 / LINE = 20, 
8515 GOSUB 13100 / LOCATE SUBROUTINE
8520 PRINT "*****************************    OPTIONS :    ********************************"      
8530 PRINT " 1 - READ THE NEXT RECORD        3 - CORRECT THIS RECORD  5 - SHOW SUBRECORDS  "
8532 PRINT " 2 - PRINT THIS RECORD ON PAPER  4 - READ ANOTHER RECORD  0 - TO FILE OPTIONS  "
8535 PRINT "******************  Enter the number then press return  **********************"
8537 SPRT = 5 / SURPRESS PRINTING AFTER OPTION IS ENTERED
8540 GOSUB 14000 / INPUT INTEGER < 100 SUBROUTINE
8542 IF DT# <0 OR DT# > 5  GOTO 8510 / IF OPTION OUT OF LIMITS THEN REPROMPT
8550 B = DT# / B = VALUE RETURNED FROM THE ABOVE SUBROUTINE
8552 IF B = 3 THEN GOSUB 9000 / IF OPTION 3 THEN CORRECT A RECORD SUBROUTINE
8554 IF B = 3 THEN GOTO 8510 / IF OPTION 3 ASK FOR ANOTHER OPTION
8555 IF SFLG > 0 AND B = 1 THEN GOTO 18380 / IF SEARCHING FOR SPECIFIC VALUES AND YOU WANT TO SEE THE NEXT RECORD THEN CONTINUE SEARCH
8556 IF B = 1 THEN RN = RN + 1 / IF SEE NEXT RECORD OPTION THEN INCREMENT RECORD NUMBER
8560 IF B = 5 AND RPT <> 2 THEN 8580 / IF REQUEST FOR SHOW SUBRECORDS AND SUBRECRDS DO NOT EXIST THEN 8580
8562 ON B GOTO 8058,8600,9000,8000,20000 / ON THE OPTION GOTO
8564 REM
8570 GOTO 3010 / TO FILE OPTIONS
8580 LI = 24 / LINE = 24
8585 GOSUB 13100 / LOCATE SUBROUTINE
8590 PRINT TAB(10) "SUBRECORDS ARE NOT SET UP ON THIS FILE";
8595 GOTO 8510 / ASK FOR ANOTHER OPTION
8600 REM  PRINT SINGLE RECORD 
8610 GOSUB 16000 / TURN YOUR PRINTER ON PROMPT
8680 GOSUB 12200 / PRINT RECORD ON PAPER EXPANDED FORM SUBROUTINE
8920 GOTO 8000 / BACK TO START OF SHOW A SINGLE RECORD
9000 REM 
9005 LI = 20 / LINE = 20
9007 GOSUB 13100 / LOCATE SUBROUTINE
9010 PRINT "*******************  CORRECT RECORD SUBROUTINE  *******************           "
9020 PRINT "          0 - TO FILE OPTION -- DONE WITH CORRECTIONS                         "    
9022 PRINT "          1 TO ";NREC(A);"THE FIELD YOU WANT TO CHANGE                    " 
9025 PRINT "***************  ENTER THE NUMBER THEN PRESS RETURN  **************           "
9028 SPRT = 5 / SURPRESS PRINTING AFTER OPTION
9030 GOSUB 14000 / INPUT INTEGER SUBROUTINE
9031 IF DT# <0 OR DT# >NREC(A)  GOTO 9030 / IF OPTION EXCEENDS LIMITS REPROMPT
9033 T = DT# / T = FIELD YOU WANT TO CORRECT
9040 IF T = 0 THEN GOTO 3010 / IF OPION = 0 THEN FILE OPTIONS
9045 D = T / D ASLO EQUALS THE FIELD TO CORRECT
9046 IF REALFLG(A) = 2 AND T = TGTRN THEN GOSUB 61300 / IF THERE IS REALTIME TRANSFERS FOR THIS FILE AND THE RECORD TO BE CHANGED IS THE POINTER TO THE TARGET RECORD NUMBER THEN GOSUB 61300
9047 Q = T / Q ALSO EQUALS FIELD TO BE CORRECTED
9048 LI = 20 / LINE = 20
9049 GOSUB 13100 / LOCATE SUBROUTINE
9050 PRINT "******  FIELD NUMBER: ";D;" FIELD NAME: ";FLDN$(A,D);" ******         "
9060 PRINT "***********  ENTER THE CORRECTION THEN PRESS RETURN  **************           "
9062 PRINT "                                                                             " / CLEARS THESE LINES
9063 PRINT "                                                                             "
9064 PRINT "                                                                             ";
9066 LI = 22 / LINE = 22
9068 GOSUB 13100 / LOCATE SUBROUTINE
9070 ON FTY(A,D) GOTO 9100,9150,9200,9250,9250 / ON THE FIELD TYPE OF THE FIELD TO CORRECT GOTO 
9100 GOSUB 15000 / INPUT STRING SUBROUTINE
9105 I$ = A$ / I$ = THE VALUE RETURED FROM THE INPUT SUBROUTINE
9110 LSET X$(D) = I$ / SET FILE BUFFER FOR THE FIELD TO I$
9120 GOTO 9290  
9150 GOSUB 14100 / INPUT INTEGER SUBROUTINE
9151 T2 = KEYLIST(A,D) / T2 = THE KEYLIST FOR THIS FIELD IF ANY
9152 T3 = MAXK(T2) / T3 = THE MAXIMUM VALUE FOR THE KEYLIST
9153 REM IF KY(A,D) = 2 AND ( DT# < 1 OR DT# > T3) GOTO 9150
9154 IF MFLG(A) = 2 THEN GOSUB 29190 / IF LIMITS THEN CHECK FOR LIMIT
9155 I% = DT# 
9157 I# = I%
9160 LSET X$(D) = MKI$(I%) / SET THE FILE BUFFER FOR THIS FIELD TO I%
9165 X(D) = I% 
9170 GOTO 9290
9200 GOSUB 14200 / INPUT SINGLE PRECISION NUMBER SUBROUTINE
9203 IF MFLG(A) = 2 THEN GOSUB 29190 / IF LIMITS THEN CHECK IF NUMBER IS IN RANGE 
9205 I! = DT# / I! = VALUE RETURNED FROM SUBROUTINE
9207 I# = I!  
9210 LSET X$(D) = MKS$(I!) / SET FILE BUFFER TO !
9220 GOTO 9290
9250 GOSUB 14300 / INPUT SUBROUTINE FOR INTEGERS
9253 IF MFLG(A) = 2 THEN GOSUB 29190 / IF LIMITS THEN CHECK IF NUMBER IS IN RANGE 
9255 I# = DT#
9260 LSET X$(D) = MKD$(I#) / SET FILE BUFFER TO !
9290 PUT #1,RN / PUT THE RECORD ON THE DISK
9291 N = D  / N ALSO EQUALS THE FIELD TO CORRCT
9294 IF REALFLG(A) = 2 AND N = FLD1 THEN GOSUB 61000 / CORRECT REALTIME TRANSFER FILE
9295 IF REALFLG(A) = 2 AND N = FLD2 THEN GOSUB 61200
9296 IF REALFLG(A) = 2 AND N = TGTRN THEN GOSUB 61400
9297 IF REALFLG(A) = 2 AND N = TGTRN THEN GOSUB 60300
9298 IF GFLG(Q) = 1 THEN  GOSUB 46000 ELSE GOSUB 44500 / IF VALUE OF THE FIELD AFFECTS OTHER FIELDS THEN RECALCULATE THE RECORD ELSE JUST PRINT ON THE SCREEN 
9299 RETURN   
```

## REMARKS2.BAS

```bas
10000 REM READ FFILE 
10010 OPEN "I",#1,"FFILE" / OPENS FFILE AS A SEQUENTIAL ACCESS FILE
10020 INPUT #1,MAXF / MAXF = THE MAXIMIM FILE NUMBER
10030 FOR A = 1 TO MAXF / START READING DATA FOR EACH FILE 
10040 INPUT #1,A,F$(A),NREC(A),L(A) / INPUT FORM DISK, FILE NUMBER, FILE NAME, NUMBER OF FIELDS IN THE FILE AND FILE LENGTH
10050 FOR N = 1 TO NREC(A) / START LOOP READING DATA FOR EACH FIELD
10060 INPUT #1,FLDN$(A,N),FTY(A,N),FL(A,N) / INPUT FROM DISK FIELD NAME, FIELD TYPE, AND FIELD LENGTH
10070 IF FTY(A,N) = 2 THEN INPUT #1,D,KEYLIST(A,N) / IF FIELD IS AN INTEGER FIELD THEN INPUT THE KEYLIST NUMBER , 0 = NO KEYLIST
10075 IF D >< 2 THEN KEYLIST(A,N) = 0 / IF FIELD IS NOT AN INTEGER FIELD THEN THERE IS NO KEYLIST
10080 NEXT N / END LOOP READING EACH FIELD
10090 NEXT A / END LOOP READING EACH FILE
10100 CLOSE #1
10110 RETURN
10900 REM  PUT DISK IN DRIVE SUB
10905 IF HDISK = 2 THEN RETURN / IF USING THE HARD DISK OPTION THEN RETURN
10910 GOSUB 13000 / CLEAR SCREEN
10920 PRINT "    ********  PUT PROGRAM DATA DISK IN THE DEFAULT DISK DRIVE  *********"
10930 PRINT ""
10940 PRINT "                     THEN PRESS ANY KEY TO CONTINUE "
10950 PRINT ""
10960 PRINT "    If the program data disk is already in the default disk drive then"
10965 PRINT "                     just press any key to continue."
10970 PRINT ""
10990 IF INKEY$ = "" GOTO 10990 / STAY ON THIS LINE UNTILL A KEY IS PRESSED
10992 GOSUB 13000 / CLEAR SCREEN
10993 PRINT "  READING INFORMATION, PLEASE WAIT "
10995 RETURN
11000 REM  LOAD KEYLIST
11010 GOSUB 13000 / CLEAR SCREEN
11100 A = 10 / NUMBER OF KEYLIST FILE, DO NOT CHANGE KEYLIST FILE UNLESS YOU KNOW WHAT YOU ARE DOING
11105 PRINT "FILE : KEYLIST "
11110 GOSUB 2300 / ASKS FOR DISK DRIVE THE FILE IS ON SUBROUTINE
11120 GOSUB 2500 / OPEN FILE NUMBER 1 SUBROUTINE
11130 FOR T = 1 TO 10000 / START READING KEYLISTS
11140 IF T > MRN GOTO 11900 / AT END OF FILE GOTO 11900
11150 GET #1,T / GET RECORD NUMBER T
11160 T1 = CVI(X$(1)) / T1 EQUALS LIST NUMBER
11170 T2 = CVI(X$(2)) / T2 EQUALS ROW NUMBER IN LIST
11180 L$(T1,T2) = X$(3) / L$ IS THE STRING CORRESPONDING TO THE KEY
11185 IF T2 > MAXK(T1) THEN MAXK(T1) = T2 / THE MAXIMUM KEY FOR THE LIST = MAXK(LIST NUMBER)
11190 NEXT T / END LOOP READING LIST
11900 KD = 5 / FLAG, LIST HAS BEEN READ
11935 CLOSE #1
11937 PRINT FRE(0) / PRINTS MEMORY AVAILABLE, OPTIONAL MAY BE DELETED
11940 RETURN
12000 REM ******  PRINT SUBROUTINE  ***** / PRINTS RECORDS ON SCREEN
12010 PRINT "*************  FILE : ";F$(A);"- ";"RECORD NUMBER: ";RN;" *************"
12015 IF CSCR = 1 GOTO 34000 / IF USING A CUSTOM SCREEN GOTO 34000
12020 FOR Q = 1 TO NREC(A) / START LOOP PRINTING EACH FIELD
12022 GOSUB 12025 
12023 NEXT Q / END LOOP PRINTING EACH FIELD
12024 RETURN
12025 IF Q MOD 19 = 0 THEN GOSUB 12170
12030 PRINT Q; TAB(5) FLDN$(A,Q); / PRINT FIELD NUMBER AND FIELD NAME
12040 ON FTY(A,Q) GOSUB 12050,12070,12100,12130,12142 / ON FIELD TYPE GOTO
12045 RETURN
12050 PRINT TAB(26) X$(Q) / PRINT THE STRING
12060 RETURN
12070 I%=CVI(X$(Q)) / CONVERT AN INTEGER FIELD
12072 X(N) = I%
12075 PRINT TAB(25) I%; / PRINT AN INTEGER FIELD
12080 IF KEYLIST(A,Q) = 0 THEN PRINT ""  / IF NO KEYLIST THEN PRINT TO NEXT LINE
12082 IF KEYLIST(A,Q) = 0 THEN GOTO 12150 / IF NO KEYLIST THEN SKIP PRINTING THE KEYLIST
12084 T1 = KEYLIST(A,Q) / T1 EQUALS THE LIST NUMBER
12085 IF I% < 0 THEN I% = 0 / CATCH NEGITIVE ARRAY VALUES
12086 W$ = L$(T1,I%) / W$ = THE KEY 
12090 PRINT TAB(30) "key: ";W$ / PRINT THE KEY
12095 RETURN 
12100 I!=CVS(X$(Q)) / CONVERT SINGLE PRECISON NUMBERS
12110 PRINT TAB(25) I! / PRINT SINGLE PRECISON NUMBERS
12120 RETURN 
12130 I#=CVD(X$(Q)) / CONVERT DOUBLE PRECISON 
12135 X(Q) = I#
12140 PRINT TAB(25)  I# / PRINT DOUBLE PRECISION NUMBERS
12141 RETURN 
12142 I#=CVD(X$(Q)) / CONVERT DOUBLE PRECISION NUMBERS FOR DOLLAR NUMBERS
12144 PRINT TAB(26);
12146 PRINT USING "**$########.##";I# / PRINT DOLLAR AMOUNTS
12147 X(Q) = I#
12148 RETURN
12150 RETURN
12152 IF Q < 20 THEN RETURN
12153 PRINT""   / CLEARS FIVE LINES FOR THE OPTION MENU
12154 PRINT ""
12155 PRINT ""
12156 PRINT ""
12157 PRINT ""
12160 RETURN
12170 PRINT "***  MORE FIELDS, PRESS ANY KEY TO CONTINUE  ***"
12180 IF INKEY$ = "" GOTO 12180 / STAY ON THIS LINE UNTILL A KEY IS PRESSED
12190 RETURN
12200 REM * LINE PRINT  / THIS SECTION IS ALMOST THE SAME AS THE ABOVE SECTION EXCEPT THAT THE DATA IS PRINTED ON PAPER NOT THE SCREEN
12210 LPRINT ""
12220 PRINT "RECORD NUMBER: ";RN 
12230 LPRINT "RECORD NUMBER: ";RN;
12235 IF CSCR = 1 THEN GOTO 35000 ELSE LPRINT "" / IF USING A CUSTOM SCREEN THEN GOTO 35000
12240 FOR Q = 1 TO NREC(A) / START LOOP PRINTING EACH FIELD
12260 LPRINT Q;TAB(5) FLDN$(A,Q);     
12270 ON FTY(A,Q) GOTO 12280,12310,12350,12390,12425 / ON FIELD TYPE GOTO
12280 REM
12290 LPRINT TAB(26) X$(Q) / PRINT STRINGS
12300 GOTO 12480
12310 I%=CVI(X$(Q)) / CONVERT INTEGERS
12314 LPRINT TAB(25) I%; / PRINT INTEGERS
12318 IF KEYLIST(A,Q) = 0 THEN LPRINT ""  / IF NO KEYLIST THEN PRINT DOWN TO THE NEXT LINE
12320 IF KEYLIST(A,Q) = 0 THEN GOTO 12480 / IF NO KEYLIST THEN SKIP PRINTING THE KEYLIST
12322 T1 = KEYLIST(A,Q) / T1 IS THE LIST NUMBER
12324 W$ = L$(T1,I%) / W$ IS THE KEY TO PRINT
12328 LPRINT TAB(30) "key: ";W$ / PRINT THE KEYLIST
12330 GOTO 12480
12340 GOTO 12480
12350 I!=CVS(X$(Q)) / CONVERT SINGLE PRECISION NUMBERS
12370 LPRINT TAB(25) I! / PRINT SINGLE PRECISION NUMBERS
12380 GOTO 12480
12390 I#=CVD(X$(Q)) / CONVERT DOUBLE PRECISION NUMBERS
12410 LPRINT TAB(25)  I# / PRINT DOUBLE PRECISION NUMBERS
12420 GOTO 12480
12425 I#=CVD(X$(Q)) / CONVERT DOLLAR AND CENTS AMOUNTS
12450 LPRINT TAB(26); 
12460 LPRINT USING "**$########.##";I# / PRINT DOLLAR AND CENTS AMOUNTS
12480 NEXT Q / FINISH LOOP PRINTING OUT FIELDS
12490 RETURN
12500 PRINT ""  / START OF PRINT CONDENSED RECORD SUBROUTINE
12510 LPRINT ""
12530 LPRINT "RECORD # ";RN;" ";
12540 FOR Q = 1 TO NREC(A) / START LOOP PRINTING EACH FIELD
12547 IF LEND(Q)= 5 THEN LPRINT "" / FLAG, IF LINE END THEN LPRINT TO NEXT LINE
12548 T2 = CL(Q) / T2 IS THE COLUMN TO PRINT THE NUMBER AT
12570 ON FTY(A,Q) GOTO 12590,12610,12730,12770,12810 / ON FIELD TYPE GOTO
12590 LPRINT TAB(T2) X$(Q); / PRINT STRINGS
12600 GOTO 12860
12610 I%=CVI(X$(Q)) / CONVERT INTEGERS
12630 LPRINT TAB(T2)I%; / PRINT INTEGERS
12660 IF KEYLIST(A,Q) = 0 THEN GOTO 12860 / IF NO KEYLIST THEN SKIP PRINTING KEYLIST
12670 T1 = KEYLIST(A,Q) / T1 IS THE KEYLIST NUMBER
12680 W$ = L$(T1,I%) / W$ IS THE KEY TO PRINT
12685 T1 = CL(Q) + 11 / T1 IS THE COLUMN TO PRINT THE KEYLIST ON
12700 LPRINT TAB(T1)"key: ";W$; / PRINT THE KEYLIST
12720 GOTO 12860
12730 I!=CVS(X$(Q)) / CONVERT SINGLE PRECISION NUMBERS
12750 LPRINT TAB(T2)I!; / PRINT SINGLE PRECISION NUMBERS
12760 GOTO 12860
12770 I#=CVD(X$(Q)) / CONVERT DOUBLE PRECISION NUMBERS
12790 LPRINT TAB(T2)I#; / PRINT DOUBLE PRECISION NUMBERS
12800 GOTO 12860
12810 I#=CVD(X$(Q)) / CONVERT DOUBLE PRECISION DOLLAR AND CENTS AMOUNTS
12840 LPRINT TAB(T2) "";  
12850 LPRINT USING "**$########,.##";I#; / PRINT DOLLAR AND CENTS AMOUNTS
12860 NEXT Q / END OF LOOP PRINTING EACH FIELD 
12870 RETURN
12880 PRINT " HOW MANY COLUMNS ARE THERE ON YOUR PRINTER "
12890 GOSUB 14100 / INPUT INTEGER SUBROUTINE
12892 COLM = DT# / NUMBER OF COLUMS EQUALS THE VALUE RETURNED FROM INPUT SUBROUTINE
12895 RETURN
12900 REM ******* TAB CONTROL *******
12901 C = 15 / FIRST FIELD STARTS AT COLUMN 15 TO LEAVE ROOM FOR THE RECORD NUMBER
12902 FOR T = 1 TO NREC(A) / START LOOP COMPUTING COLUMN TO PRINT FIELDS IN
12903 LEND(T) = 0 / LINE END = NO
12905 CL(T)= C / COLUMN SET TO END OF LAST FIELD
12906 GOSUB 12910
12907 IF C > COLM THEN GOSUB 12970 /IF COLUMN IS GREATER THEN PRINT GOSUB 12970
12908 NEXT T / FINISH LOOP COMPUTING TABS
12909 RETURN
12910 ON FTY(A,T) GOTO 12920,12930,12940,12950,12950 / ON FIELD TYPE GOTO
12920 C = C + FL(A,T) + 1 / FOR STRINGS ALLOW THE STRING LENGTH PLUS 1
12925 RETURN     
12930 C = C + 7 / FOR INTEGERS ALLOW 7 SPACES
12933 IF KEYLIST(A,T) > 0 THEN C = C + 30 / FOR KEYLISTS ALLOW 30 SPACES
12935 RETURN
12940 C = C + 9 / FOR SINGLE PRECISION NUMBERS ALLOW 9 SPACES
12945 RETURN    
12950 C = C + 16 / FOR DOUBLE PRECISION AND DOLLAR AMOUNTS ALLOW 16 SPACES
12952 RETURN
12970 CL(T)= 1 / START NEXT LINE AT COLUMN 1
12972 C =1
12974 LEND(T) = 5 / LINE END FLAG EQUALS YES
12975 GOSUB 12910 
12980 RETURN
13000 REM  CLEAR SCREEN
13010 CLS
13020 RETURN
13050 REM  LOCATE - TAB SET IN PROGRAM
13060 GOTO 13110 / SKIP SETTING TAB TO ONE
13100 REM  LOCATE - TAB EQUALS ONE
13105 TB = 1 / COLUMN EQUALS ONE
13110 LOCATE LI,TB
13120 RETURN
13600 REM CHECK FOR ASC0 / CHECK INPUTS FOR EXTENDED ASCII CODE
13610 S4$ = INKEY$ / S4$ IS THE SECOND ASCII CODE 
13620 C2 =  ASC(S4$) / C2 IS THE NUMBER OF THE ASCII CODE
13630 IF C2 = 83 THEN C = 1 / SET DELETE EQUAL TO CONTROL A
13640 IF C2 = 82 THEN C = 6 / SET INSERT EQUAL TO CONTROL F
13650 IF C2 = 75 THEN C = 19 / SET CURSER LEFT EQUAL TO CONTROL S
13660 IF C2 = 77 THEN C = 4  / SET CURSER RIGHT EQUAL TO CONTROL D
13670 RETURN
14000 REM INTEGER LESS THEN 100 CHECK
14010 MAX = 2 / MAXIMUM OF TWO CHARACTERS
14020 ACT$ = " 1234567890=<>^" / ACCEPTABLE CHARACTERS FOR NEW ENTRY
14023 IF NE = 0 THEN ACT$ = " 1234567890" / ACCEPTABLE CHARACTERS 
14025 PRINT ">__<";
14030 GOTO 14500
14100 REM INTEGER
14110 MAX = 8 / MAXIMUM OF EIGHT CHARACTERS
14120 ACT$ = " 1234567890-+,=<>^" / ACCEPTABLE CHARACTERS FOR NEW ENTRY
14123 IF NE = 0 THEN ACT$ = " 1234567890-+," / ACCEPTABLE CHARACTERS
14125 PRINT ">________<"; / PROMPT
14130 GOTO 14500
14200 REM  SINGLE PRECISION
14210 MAX = 10 / MAXIMUM OF TEN CHARACTERS
14220 ACT$ = " 1234567890-+,.%$=<>^" / ACCEPTABLE CHARACTERS FOR NEW ENTRY
14223 IF NE = 0 THEN ACT$ = " 1234567890+-,.%$" / ACCEPTABLE CHARACTERS
14225 PRINT ">__________<"; 
14230 GOTO 14500
14300 REM DOUBLE PRECISION
14310 MAX = 20 / MAXIMUM OF 20 CHARACTERS
14320 ACT$ = " 1234567890-+,.%$=<>^" / ACCEPTABLE CHARACTERS FOR NEW ENTRY
14323 IF NE = 0 THEN ACT$ = " 1234567890+-,.%$" / ACCEPTABLE CHARACTERS
14325 PRINT ">____________________<";
14330 GOTO 14500
14500 REM NUMBER CHECK
14505 A$ = "" / INITIALIZE A$ TO THE NULL STRING
14510 K$(20) = " " 
14515 KTMAX = 0 / INITIALIXE THE COUNT MAXIMUM TO 0
14520 FOR T9 = 1 TO MAX 
14525 K$(T9) = " " / INITIALIZE K$ TO BLANK
14530 NEXT T9
14535 DIG$ = "1234567890." / STORED CHARACTERS
14540 DOTFLG = 0 / DECIMAL POINT FLAG SET TO 0
14541 T2 = MAX + 1 
14542 FOR T6 = 1 TO T2
14544 PRINT CHR$(CH); / BACKSPACE TO FIRST SPACE
14546 NEXT T6
14550 IF INKEY$ = "" GOTO 14560 ELSE GOTO 14550 / CLEAR THE KEYBOARD BUFFER
14560 KT = 0 / INITIALIZE COUNT TO 0
14565 REM 
14570 KT = KT + 1 / INCREMENT COUNT
14575 REM     
14580 W$ = INKEY$ / GET CHARACTER FROM KEYBOARD
14585 IF W$ = "" GOTO 14580 /IF THERE IS NO CHARACTER LOOP UNTILL ON IS ENTERED
14590 C = ASC(W$) / C EQUALS THE ASCII VALUE OF THE ENTERED CHARACTER
14593 IF C = 0 THEN GOSUB 13600 / CHECK EXTENDED ASCII CODES
14595 IF C = 13 GOTO 14660 / RETURN 
14600 IF C = 17 OR C = 8 GOTO 14860 / BACKSPACE
14605 IF C = 19 GOTO 14690 / CURSER LEFT
14610 IF C = 4 GOTO 14710 / CURSER RIGHT
14615 IF C = 6 GOTO 14730 / INSERT
14620 IF C = 1 GOTO 14790 / DELETE
14625 IF KT > MAX GOTO 14575 / DOES NOT ACCEPT CHARACTERS BEYOND THE MAX LIMIT
14630 IF INSTR(ACT$,W$) = 0 GOTO 14890 / IF W$ IS NOT ONE OF THE ACCEPTABLE CHARACTERS THEN GOTO UNACCEPTABLE CHARACTER SUBROUTINE
14635 K$(KT) = W$ / SAVE THE CHARACTER ENTERED AS K$(COUNT)
14645 PRINT K$(KT); / PRINT THE CHARACTER ON THE SCREEN
14650 IF KT > KTMAX THEN KTMAX = KT / IF COUNT IS GREATER THEN COUNT MAX THEN COUNT MAX EQUALS THE COUNT
14655 GOTO 14570 / BACK TO GET ANOTHER CHARACTER
14660 REM * RETURN / DONE WITH ENTERY
14670 FOR T9 = 1 TO KTMAX / FOR EACH CHARACTER ENTERED
14675 A$ = A$ + K$(T9) / A$ = ALL THE CHARACTERS STRUNG (CONCATED) TOGETHER
14676 IF K$(T9) = "^" GOTO 15830 / NEW ENTRY OPTION SAME AS LAST RECORD OVER 1
14677 IF K$(T9) = ">" GOTO 15950 / NEW ENTRY OPTION ABORT RECORD
14678 IF K$(T9) = "=" GOTO 15800 / NEW ENTRY OPTION  SAME AS LAST RECORD
14679 IF K$(T9) = "<" GOTO 15900 / NEW ENTRY OPTION START RECORD OVER
14680 NEXT T9
14681 IF KTMAX = 0 THEN PRINT "1"; / DEFAULT = 1
14682 IF KTMAX = 0 THEN DT# = 1 / DEFAULT = 1
14684 IF SPRT >< 5 THEN PRINT "" / IF PRINTING IS NOT SUPRESSED THEN PRINT TO NEXT LINE / THIS IS NECESSARY IF THE PROMPT IS ON THE 24 TH LINE ON IBM BASIC OTHERWISE THE SCREEN WILL SCROLL UP ONE LINE
14685 SPRT = 0 / SET SURPRESS PRINT FLAG TO NO 
14686 IF KTMAX = 0 THEN RETURN / IF DEFAULT THEN RETURN
14687 GOTO 14905
14689 GOTO 14905
14690 REM * MOVE CURSE BACK
14695 IF KT = 1 GOTO 14575 / CAN'T MOVE CURSER BACK ANY MORE
14700 KT = KT - 1 / COUNT = COUNT -1
14703 PRINT CHR$(CH); / BACKSPACE ONE SPACE
14705 GOTO 14575
14710 REM * MOVE CURSER FORWARD
14715 IF KT >= MAX GOTO 14575 / CAN'T MOVE CURSER FORWARD ANY
14716 IF KT > (KTMAX + 1) GOTO 14575 / CANT MOVE CURSER FORWARD
14718 PRINT K$(KT); / PRINT ONE CHARACTER RIGHT
14720 KT = KT + 1 / COUNT = COUNT + 1
14725 GOTO 14575
14730 REM * INSERT 
14733 IF KT > KTMAX GOTO 14575 / CAN'T INSERT HERE
14735 X9 = MAX 
14740 WHILE X9 > KT
14745 X9 = X9 - 1
14750 K$(X9 + 1) = K$(X9) / MOVE ALL THE CHARACTERS OVER ONE
14755 WEND 
14760 K$(KT) = " "
14767 KTMAX = KTMAX + 1 / INCREMENNT THE MAXIMUM COUNT
14769 IF KTMAX > MAX THEN KTMAX = MAX / DO NOT INCREMENT BEYOND THE MAX
14770 FOR T9 = KT TO KTMAX  
14775 PRINT K$(T9); / PRINT OUT THE NEW CHARACTERS
14780 NEXT T9
14781 T6 = (KTMAX - KT) + 1
14782 FOR T7 = 1 TO T6
14783 PRINT CHR$(CH); / MOVE CURSER BACK
14784 NEXT T7
14785 GOTO 14575
14790 REM * DELETE 
14793 IF KT > KTMAX GOTO 14575 / DO NOT DELETE IF NOTHING LEFT TO DELETE
14794 IF KTMAX = 1 GOTO 14575 / DO NOT DELETE IF ONLY ONE CHARACTER
14795 K$(MAX + 1) = ""
14800 X9 = KT 
14805 WHILE X9 <= MAX
14810 K$(X9) = K$(X9 + 1) / MOVE CHARACTERS OVER ONE
14815 X9 = X9 + 1
14820 WEND 
14830 KTMAX = KTMAX - 1 / DECREMENT KTMAX
14835 FOR T9 = KT TO KTMAX
14840 PRINT K$(T9); / PRINT NEW CHARACTERS
14845 NEXT T9
14850 PRINT "_"; / PRINT UNDERLINE OVER LAST CHARACTER
14851 T7 = (KTMAX - KT) + 2
14852 FOR T8 = 1 TO T7
14853 PRINT CHR$(CH); / MOVE CURSER BACK
14854 NEXT T8
14855 GOTO 14575
14860 REM BACKSPACE
14865 IF KT = 1 GOTO 14575 / CAN'T BACKSPACE PAST FIRST CHARACTER
14870 KT = KT - 1 / DECREMENT COUNT
14875 PRINT CHR$(CH); / BACKSPACE
14877 K$(KT) = " " / CHANGE LAST CHARACTER TO A BLANK
14880 PRINT "_"; / PRINT UNDERLINE OVER BACKSPACED CHARACTER
14883 PRINT CHR$(CH); / BACKSPACE
14885 GOTO 14575
14890 REM INPUT NOT ACCEPTABLE
14895 PRINT CHR$(7); / BEEPS
14900 GOTO 14580
14905 REM * CLEAR STRINGS
14910 MAX = LEN(A$) / SETS MAX EQUAL TO THE LENGTH OF A$, A$ IS THE STRING OF ALL THE CHARACTERS
14915 D2$ = "" / INITIALIZE TO NULL
14920 D1$ = "" / INITIALIZE TO NULL
14925 DFLG = 0 / INITIALIZE DECIMAL FLAG TO 0
14930 FOR Q93 = 1 TO MAX / START LOOP TESTING EACH CHARACTER
14935 R$ = MID$(A$,Q93,1) / R$ IS THE CHARACTER TO TEST
14940 IF INSTR(DIG$,R$) = 0 GOTO 14975 / CHARACTER NOT A DIGIT OR DECIMAL POINT
14945 IF R$ = "." OR DFLG = 1 GOTO 14965 / START DECIMAL POINT
14950 IF DFLG = 1 GOTO 14965
14955 D2$ = D2$ + R$ / D2$ CONTAINS ALL CHARACTERS TO THE LEFT OF DECIMAL POINT
14960 GOTO 14975
14965 D1$ = D1$ + R$ / D1$ CONTAINS ALL THE CHARACTERS TO THE RIGHT OF DECIMAL 
14970 DFLG = 1 / SET DECIMAL FLAG TO 1
14975 NEXT Q93 / GET NEXT CHARACTER
14980 DA# = VAL(D2$) / CONVERT TO NUMBER
14985 D1# = VAL(D1$) / CONVERT STRING TO NUMBER
14990 DT# = DA# + D1# / ADD THE WHOLE NUMBER TO THE FRACTIONAL NUMBER
14995 IF K$(1) = "-" THEN DT# =  -DT# / CHANGE TO NEGITIVE IF APPLICABLE
14997 RETURN / RETURN TO THE SPOT IN THE PROGRAM THAT CALLED IT , DT# IS THE RETURNED RESULT
15000 REM * ALPHANUMERIC CHECK
15010 MAX = FL(A,Q) / THE MAXIMUM LENGTH OF THE ENTRY IS SET EQUAL TO THE FIELD LENGTH
15020 GOTO 15040
15030 REM * MAX SET IN PROGRAM
15040 A$ = ""  / INITIALIXE TO NULL STRING
15050 PRINT ">";         / PRINTS PROMPT
15060 FOR N9 = 1 TO MAX  / "
15065 K$(N9) = ""        / "
15070 PRINT "_";         / "
15080 NEXT N9            / "
15090 PRINT "<";         / "
15100 T2 = MAX + 1
15110 FOR T4 = 1 TO T2
15120 PRINT CHR$(CH); / MOVES CURSER BACK TO FIRST CHARACTER
15125 NEXT T4
15130 KT = 0 / INITIALIZE TO 0
15135 KTMAX = 1 / INITIALIZE TO 1
15140 REM * CHECK ALFANUMERIC INPUT FOR LENGTH
15150 KT = KT + 1
15160 PRINT TAB(KT+1)"";
15170 K$ = INKEY$ / GET CHARACTER FROM KEYBOARD
15180 IF K$ = "" GOTO 15170 / LOOP UNTILL CHARACTER IS NOT A NULL
15190 C = ASC(K$) / C IS THE ASCII VALUE OF THE CHARACTER
15195 IF C = 0 THEN GOSUB 13600 / CHECK EXTENDED ASCII CODES
15200 IF C = 13 GOTO 15310 / RETURN 
15210 IF C = 17 OR C = 8 GOTO 15710 / BACKSPACE
15220 IF C = 19 GOTO 15370 / CURSER LEFT
15230 IF C = 4  GOTO 15410 / CURSER RIGHT
15240 IF C = 6 GOTO 15450 / INSERT
15250 IF C = 1 GOTO 15570 / DELETE
15260 IF KT > MAX GOTO 15160 / CAN'T INPUT PAST MAXIMUM CHARACTER
15270 K$(KT) = K$ / K$(COUNT) EQUALS THE CHARACTER
15290 PRINT K$(KT); / PRINT THE CHARACTER
15295 IF KT > KTMAX THEN KTMAX = KT  / IF COUNT IS GREATER THEN MAXIMUM COUNT THEN MAXIMUM COUNT EQUALS THE COUNT
15300 GOTO 15150
15310 REM * RETURN
15320 FOR T9 = 1 TO MAX
15330 A$ = A$ + K$(T9) / A$ IS ALL THE CHARACTERS STRUNG (CONCATED) TOGETHER
15332 IF K$(T9) = "^" GOTO 15830 / NEW ENTRY OPTION SAME AS LAST RECORD OVER 1
15333 IF K$(T9) = ">" GOTO 15950 / NEW ENTRY OPTION ABORT ENTRY
15335 IF K$(T9) = "=" GOTO 15850 / NEW ENTRY OPTION  EQUALS LAST RECORD 
15338 IF K$(T9) = "<" GOTO 15900 / NEW ENTRY OPTION START RECORD OVER
15340 NEXT T9
15350 PRINT "" / PRINTS TO NEXT LINE
15360 RETURN  / TO PROGRAM WHERE THE INPUT SUBROUTINE WAS CALLED FROM, A$ IS THE RETURNED STRING
15370 REM * MOVE CURSE BACK
15380 IF KT = 1 GOTO 15160 / CAN'T MOVE CURSOR PAST FIRST CHARACTER
15385 KT = KT - 1 / COUNT EQUALS COUNT - 1
15390 PRINT CHR$(CH); / BACKSPACE ONE CHARACTER
15400 GOTO 15160
15410 REM * MOVE CURSER FORWARD
15420 IF KT >= MAX GOTO 15160 / CAN'T MOVE CURSER FORWARD
15425 IF KT >  KTMAX  GOTO 15160 / CAN'T MOVE CURSOR FORWARD
15427 PRINT K$(KT); / PRINT OVER ONE CHARACTER
15430 KT = KT + 1 / COUNT = COUNT PLUS ONE
15440 GOTO 15160 
15450 REM INSERT*
15460 X9 = MAX
15470 WHILE X9 > KT
15480 X9 = X9 - 1
15490 K$(X9 + 1) = K$(X9) / MOVE CHARACTERS OVER ONE
15500 WEND 
15510 K$(KT) = " " / PRINT A BLANK WHERE THE CURSER IS
15520 KTMAX = KTMAX + 1 / MAXIMUM COUNT = MAXIMUM COUNT + 1
15525 IF KTMAX > MAX THEN KTMAX = MAX / IF THE COUNT MAXIMUM IS GREATER THEN THE MAXIMUM THEN THE COUNT MAXIMUM EQUALS THE MAXIMUM
15530 FOR T9 = KT TO KTMAX  
15540 PRINT K$(T9); / PRINT THE NEW CHARACTERS
15550 NEXT T9
15552 T6 = (KTMAX - KT) +1
15554 FOR T7 = 1 TO T6
15556 PRINT CHR$(CH); / BACKSPACE TO WHERE THE CURSOR WAS
15558 NEXT T7
15560 GOTO 15160
15570 REM *DELETE
15575 IF KT > KTMAX GOTO 15170 / CAN'T DELETE HERE
15578 IF KTMAX = 1 GOTO 15160 / CAN'T DELETE HERE
15580 K$(MAX + 1) = "" / INITILIZE TO NULL
15590 X9 = KT 
15600 WHILE X9 <= KTMAX
15610 K$(X9) = K$(X9 + 1) / MOVE CHARACTERS OVER
15620 X9 = X9 + 1
15630 WEND 
15650 KTMAX = KTMAX - 1
15660 FOR T9 = KT TO KTMAX
15670 PRINT K$(T9); / PRINT NEW CHARACTERS
15680 NEXT T9
15690 PRINT "_";
15692 T7 = (KTMAX - KT) + 2 
15694 FOR T6 = 1 TO T7
15696 PRINT CHR$(CH); / BACKSPACE TO WHERE THE CURSER WAS
15698 NEXT T6
15700 GOTO 15160
15710 REM * BACKSPACE
15720 IF KT = 1 GOTO 15160 /CAN'T BACKSPACE
15725 K$(KT) = " " / SET TO BLANK
15730 KT = KT - 1 / DECREMENT COUNT
15735 K$(KT) = " " 
15740 PRINT CHR$(CH); / BACKSPACE
15750 PRINT "_"; / PRINT UNDERLINE
15755 PRINT CHR$(CH); / BACKSPACE
15760 GOTO 15160 
15800 REM * SAME ENTRY AS LAST RECORD
15810 DT# = X(N) / RETURNS THE VALUE OF THE LAST RECORD AS DT#
15820 RETURN
15830 REM * SAME ENTRY AS LAST RECORD OVER ONE COLUMN
15835 DT# = X(N + 1) / RETURNS THE VALUE OF THE LAST RECORD OVER ONE AS DT#
15840 RETURN
15850 REM * SAME ENTRY AS LAST RECORD ALFANUMERIC
15860 A$ = CK$(N) / RETURNS THE SAME ENTRY AS LAST RECORD AS A$
15870 RETURN
15900 REM RESTART DATA ENTRY*
15910 REFLG = 1 / RESTART FLAG = YES RESTART
15915 IF NE = 0 GOTO 15340 / IF THIS IS NOT A NEW ENTRY THEN DISREGARD
15920 RETURN
15950 REM * ABORT NEW DATA ENTRY
15960 IF NE = 0 GOTO 15340 / IF THIS IS NOT A NEW ENTRY THEN DISREGARD 
15970 ABORTFLG = 1 / ABORT FLAG = YES ABORT
15980 RETURN
16000 GOSUB 13000 / CLEAR SCREEN
16010 PRINT "***********  MAKE SURE YOUR PRINTER IS ON  **************"
16020 PRINT ""
16030 PRINT "********************  WITH PAPER  ***********************"
16040 PRINT ""
16050 PRINT "**********  PRESS ANY KEY TO START PRINTING  ************"
16055 PRINT ""
16057 PRINT "     *******  PRESS THE LETTER A TO ABORT  *******"
16070 T$ = INKEY$
16073 IF T$ = "" GOTO 16070 / LOOP UNTIL A KEY IS PRESSED
16075 PRINT T$
16085 IF T$ = "A" OR T$ = "a" THEN GOTO 3010 / IF "A" IS PRESSED THEN GOTO FILE OPTIONS
16090 RETURN
16200 REM * PRINT OUT FIELDS
16205 T2 = 1 / INITIALIZE TAB TO 1
16210 FOR T = 1 TO NREC(A) / START LOOP PRINTING FIELD NAMES
16220 PRINT TAB(T2) T;"-";FLDN$(A,T); / PRINT FIELD NUMBER AND NAME
16230 IF T MOD 2 = 0 THEN PRINT "" /  IF EVEN NUMBER FIELD PRINT TO NEXT LINE
16235 IF T MOD 2 = 0 THEN T2 = -25 / IF EVEN NUMBER FIELD RESET TAB
16237 T2 = T2 + 26 / INCREMENT TAB BY 26
16340 NEXT T
16350 RETURN
16800 REM *  HARD DISK OPTION
16810 GOSUB 13000 / CLEAR SCREEN
16820 PRINT "****************  ARE YOU USING A HARD DISK  *******************"
16830 PRINT ""
16840 PRINT "          1 - NO , I AM USING FLOPPY DISKS"
16845 PRINT ""
16850 PRINT "          2 - YES, I AM USING A HARD DISK"
16852 PRINT "               with all my files on the hard disk"
16854 PRINT "               and the hard disk is the default drive"
16860 PRINT ""
16870 PRINT "*************  ENTER THE NUMBER THEN PRESS RETURN  *************"
16880 GOSUB 14000 / INTEGER INPUT SUBROUTINE
16890 IF DT#<1 OR DT#>2 GOTO 16880 / IF INPUT OUT OF RANGE THEN REPROMPT
16900 HDISK = DT# / HARD DISK FLAG DT# (RETURNED FROM INPUT SUBROUTINE)
16910 RETURN
17000 REM
17005 RNB = 0
17010 GOSUB 13000 / CLEAR SCREEN
17020 PRINT "******************  SEARCH A SORTED FILE  *******************"
17030 PRINT ""
17040 GOSUB 16200  / PRINT FIELDS SUBROUTINE
17060 PRINT ""
17070 PRINT "***********  ENTER ZERO TO RETURN TO INITIAL MENU  **********"
17080 PRINT ""
17090 PRINT "************  WHAT FIELD IS THIS FILE SORTED BY  ************"
17100 GOSUB 14000 / INPUT INTEGER SUBROUTINE
17101 IF DT# <0 OR DT# >NREC(A)  GOTO 17100 / IF OPTION OUT OF RANGE REENTER 
17105 SF = DT# / SF, SEARCH THIS FIELD EQUALS THE NUMBER RETURNED FROM INPUT SUBROUTINE
17110 IF SF = 0 GOTO 3010 / IF OPTION 0 RETURN TO FILE OPTION
17120 PRINT "*********  WHAT VALUE DO YOU WANT TO SEARCH FOR ?  **********"
17130 PRINT FLDN$(A,SF);"=" ; 
17150 ON FTY(A,SF) GOTO 17160,17200,17250,17300 / ON FIELD TYPE GOTO
17160 MAX = FL(A,SF) / MAXIMUM INPUT STRING EQUALS THE FIELD LENGTH OF THE FIELD WE ARE SEARCHING
17162 GOSUB 15030 / INPUT STRING SUBROUTINE
17164 SV$ = A$ / SV$, THE VALUE TO SEARCH FOR EQUALS A$ ( RETURNED FROM SUBROUTINE
17166 LN = LEN(A$) / LN = LENGTH OF THE STRING YOU ARE SEARCHING FOR
17170 GOTO 17350 
17200 GOSUB 14100 / INPUT INTEGER SUBROUTINE
17202 SV% = DT# / SEARCH VALUE EQUALS VALUE RETURNED FROM SUBROUTINE
17205 SV$ = MKI$(SV%) / CONVERT SEARCH VALUE TO A STRING
17210 GOTO 17350
17250 GOSUB 14200 / INPUT SINGLE PRECISION SUBROUTINE
17252 SV! = DT# / SEARCH VALUE EQUALS VALUE RETURNED FROM SUBROUTINE
17255 SV$ = MKS$(SV!) / CONVERT SEARCH VALUE TO A STRING
17260 GOTO 17350 
17300 GOSUB 14300 / INPUT DOUBLE PRECISION SUBROUTINE
17303 INPUT SV# 
17305 SV$ = MKD$(DT#) / CONVERT TO A STRING
17350 REM START SEARCH*
17360 RN = 8192 / INITIALIZE RECORD NUMBER TO 8192
17365 I!= RN  / INITIALIZE I! TO 8192
17368 IF RN > MRN GOTO 17800 / IF RECORD NUMBER IS GREATER THEN THE MAXIMUM RECORD NUMBER THEN GOTO 17800
17370 GET #1,RN / GET RECORD NUMBER RN
17375 I!= I!/ 2 / REDUCE THE INCREMENT VALUE BY HALF
17376 IF FTY(A,SF) = 1 THEN XT$ = LEFT$(X$(SF),LN) ELSE XT$=X$(SF) / IF THE SEARCH FIELD IS A STRING THEN TAKE THE LEFT PART OF THE STING WITH LENGTH LN. IF THE SEARCH VALUE IS A NUMBER THE LEAVE IT THE WAY IT IS.
17377 IF I!< 1  THEN GOTO 17900 / IF INCREMENT VALUE IS LESS THEN ONE THEN END SEARCH
17378 IF XT$ = SV$ THEN RNB = RN / IF THE FIELD AND SEARCH VALUE MATCH THEN SET RNB (RECORD NUMBER BACKUP MATCH) TO RECORD NUMBER
17380 IF XT$ < SV$ THEN GOTO 17500 / IF THE FIELD IS LESS THEN THE VALUE SEARCHING FOR GOTO 17500
17390 RN = RN - I! / SUBTRACT INCREMENT VALUE FROM RECORD NUMBER
17400 GOTO 17368
17500 RN = RN + I! / ADD INCREMENT VALUE TO RECORD NUMBER
17510 GOTO 17368
17600 REM
17610 GOTO 8057 / SHOW RECORD ON SCREEN
17800 REM ON ERROR ROUTINE / IS NO LONGER AN ON ERROR ROUTINE. RECORD NUMBER LARGER THEN MAXIMUM FILE NUMBER
17801 I!= I!/ 2 / HALF INCREMENT VALUE
17802 IF I!< 1 GOTO 17900 / IF INCREMENT VALUE LESS THEN ONE END SEARCH
17805 RN = RN - I! / SUBTRACT RECORD NUMBER FROM INCREMENT VALUE
17810 GOTO 17368 / CONTINUE SEARCH
17900 IF XT$ = SV$ THEN GOTO 17950 / IF CURRENT RECORD MATCHES GOTO 17950
17902 IF RNB > 0 THEN RN = RNB / IF BACKUP MATCH THEN RECORD NUMBER = RECORD BACKUP MATCH.  
17904 IF RNB > 0 THEN GOTO 8057 / IF BACKUP MATCH THEN SHOW RECORD ON SCREEN
17906 PRINT " RECORD NOT FOUND "
17910 GOTO 17000 / BACK TO INITIAL SEARCH MENU
17950 PRINT "RN = ";RN
17960 GOTO 8057 / SHOW RECORD ON SCREEN
18000 REM 
18005 SFLG = 1 / SEARCH FLAG EQUALS YES
18010 GOSUB 13000 / CLEAR SCREEN
18020 PRINT "*********************  SEARCH  FILE  ***********************"
18030 PRINT ""
18040 GOSUB 16200 / PRINT FIELDS SUBROUTINE
18060 PRINT ""
18070 PRINT "***********  ENTER ZERO TO RETURN TO INITIAL MENU  **********"
18080 PRINT ""
18090 PRINT "*************  WHICH FIELD DO YOU WANT TO SEARCH  ***********"
18100 GOSUB 14000 / INPUT INTEGER LESS THE 100 SUBROUTINE
18101 IF DT# <0 OR DT# >NREC(A) GOTO 18100 / IF INPUT OUT OF RANGE THEN REENTER
18105 SF = DT# / SEARCH FIELD EQUALS NUMBER RETURNED FROM SUBROUTINE
18110 IF SF = 0 GOTO 3010 / IF OPTION = 0 THEN GOTO FILE OPTIONS
18120 PRINT "*********  WHAT VALUE DO YOU WANT TO SEARCH FOR ?  **********"
18130 PRINT FLDN$(A,SF);"=" 
18150 ON FTY(A,SF) GOTO 18160,18200,18250,18300 / ON FIELD TYPE OF THE SEARCHED FIELD GOTO
18160 MAX = FL(A,SF) / MAXIMUM LENGTH OF STRING TO INPUT EQUALS FIELD LENGTH
18162 GOSUB 15030 / INPUT STRING SUBROUTINE
18164 SV$ = A$ / SEARCH VALUE EQUALS VALUE RETURNED FROM INPUT SUBROUTINE
18166 LN = LEN(A$) / LN EQUALS LENGTH OF A$
18170 GOTO 18350 / GOTO START SEARCH
18200 GOSUB 14100 / INPUT INTEGER SUBROUTINE 
18202 SV% = DT# / SEARCH VALUE EQUALS VALUE RETURNED FROM INPUT SUBROUTINE
18205 SV$ = MKI$(SV%) / CONVERT SEARCH VALUE TO A STRING
18210 GOTO 18350 / GOTO START SEARCH
18250 GOSUB 14200 / INPUT SINGLE PRECISION SUBROUTINE
18252 SV! = DT# / SEARCH VALUE EQUALS VALUE RETURNED FROM INPUT SUBROUTINE
18255 SV$ = MKS$(SV!) / CONVERT SEARCH TO A STRING
18260 GOTO 18350 / GOTO START SEARCH
18300 GOSUB 14300 / INPUT DOUBLE PRECISION SUBROUTINE
18303 INPUT SV#  
18305 SV$ = MKD$(DT#) / CONVERT SEARCH VALUE TO A STRING
18350 REM * START SEARCH
18360 GOSUB 18800 / GET STARTING RECORD NUMBER
18365 FOR RN = RNSS TO MRN / START SEARCH LOOP FOR RECORD NUMBER START SEARCH TO MAXIMUM RECORD NUMBER
18370 GET #1,RN / GET RECORD NUMBER RN
18376 IF FTY(A,SF) = 1 THEN XT$ = LEFT$(X$(SF),LN) ELSE XT$=X$(SF) / IF SEARCH FIELD IS A STRING THEN TAKE THE LEFT PART OF THE STING EQUAL IN LENGTH TO THE VALUE YOU ARE SEARCHING FOR. IF A NUMBER TAKE ENTIRE FIELD
18378 IF XT$ = SV$ THEN GOTO 8057 / IF FIELD AND SEARCH VALUE MATCH THE SHOW RECORD
18380 NEXT RN / END OF SEARCH LOOP
18390 GOTO 3010 / GOT TO FILE OPTIONS
18800 REM *  GET STARTING AND ENDING FILE
18803 PRINT ""
18805 PRINT "MINIMUM RECORD NUMBER = 1  MAXIMUM RECORD NUMBER = ";MRN
18810 PRINT "******  WHICH RECORD NUMBER DO YOU WANT TO START THE SEARCH AT  ******"
18820 GOSUB 14100 / INPUT INTEGER SUBROUTINE
18830 IF DT#<1 OR DT#>MRN THEN 18820 / RECORD NUMBER OUT OF RANGE THEN REENTER
18840 RNSS = DT# / RECORD NUMBER START SEARCH EQUAL THE VALUE RETURNED FROM THE INPUT SUBROUTINE
18900 RETURN
```

## REMARKS3.BAS

```bas
20000 REM *****  GET UPPER LIMIT 
20010 GOSUB 20050 / GET UPPER AND LOWER LIMITS OF RELATED SUBRECORDS SUBROUTINE
20020 GOSUB 20400 / INITIALIZE SUMS TO ZERO SUBROUTINE
20030 GOTO 21000 / PRINT REPEATING FIELDS SUBROUTINE
20050 RNU = RN / INITIALZE RECORD NUMBER UPPER TO RECORD NUMBER
20060 TESTH$ = TEST$ / TEST HOLD = TEST$ OF THE CURRENT RECORD NUMBER.  THE NON REPEATING PART OF THE RECORD WAS FIELDED AS TEST$.
20100 WHILE TEST$ = TESTH$ / WHILE THERE IS NO CHANGE IN THE NONREPEATING PART OF THE RECORD  
20110 RNU = RNU - 1 / DECREMENT RECORD NUMBER UPPER
20115 IF RNU = 0 THEN GOTO 20140 / CAN'T DECREMENT TO ZERO
20120 GET #1,RNU / GET RECORD NUMBER
20130 WEND / END LOOP
20140 RNU = RNU + 1 / ADD ONE TO RECORD NUMBER BECAUSE WE WENT ONE PAST IT 
20200 REM * GET LOWER LIMIT 
20250 RNL = RN / INITIALIZE RECORD NUMBER LOWER TO CURRENT RECORD NUMBER
20290 GET #1,RNL / GET RECORD NUMBER LOWER
20300 WHILE TEST$ = TESTH$ / WHILE THERE IS NO CHANGE IN THE REPEATING PART OF THE RECORD
20310 RNL = RNL + 1 / INCREMENT RECORD NUMBER LOWER
20315 IF RNL > MRN THEN GOTO 20340 / CAN'T INCREMENT PAST END OF FILE
20320 GET #1,RNL / GET RECORD NUMBER LOWER
20330 WEND
20340 RNL = RNL - 1 / SUBTRACT ONE SINCE WE WENT ONE PAST IT 
20350 RETURN
20400 REM * SET SUMS TO ZERO
20410 FOR T = 1 TO 28 / START LOOP.
20420 SUM#(T) = 0 / INITIALIZE SUM TO ZERO
20430 NEXT T
20450 RETURN
21000 REM *  PRINT REPIOTIOUS FIELDS
21050 OFFSET = -1 / INITIALZE OFFSET TO -1
21100 FOR TH = RNU TO RNL / START LOOP TO PRINT ALL RELATED SUBRECORDS
21105 OFFSET = OFFSET + 1 / INCREMENT THE OFFSET BY ONE
21110 GET #1,TH / GET THE RECORD NUMBER
21120 T2 = LSTE + 1 / T2 EQUALS THE FIELD NUMBER OF THE FIRST REPEATING FIELD
21130 FOR N = T2 TO NREC(A) / START LOOP TO PRINT ALL REPEATING FIELDS
21140 GOSUB 34110 / PRINT EACH REPEATING FIELD SUBROUTINE
21150 NEXT N / END EACH FIELD LOOP
21160 NEXT TH / END EACH RECORD NUMBER LOOP
21180 LI = 1 / LINE NUMBER
21182 TB = 47 / COLUMN NUMBER 47
21185 GOSUB 13050 / LOCATE SUBROUTINE
21190 PRINT "RECORDS";RNU;" TO ";RNL;"  *******"
21195 RN = RNL / CHANGE CURRENT RECORD NUMBER TO RECORD NUMBER LOWER
21200 GOTO 8510 / RETURN TO OPTIONS
26000 REM 
26100 EFLG = 1 / END OF FILE FLAG EQUALS YES
26200 PRINT "**********  END OF FILE  ***********"
26202 PRINT "**** PRESS ANY KEY TO CONTINUE ****"
26204 IF INKEY$ = "" GOTO 26204 / LOOP UNTILL ANY KEY IS PRESSED
26210 GOTO  3010 / RETURN TO FILE OPTIONS
26500 REM 
26600 PRINT "**********  END OF FILE  ***********"
26610 PRINT "**** PRESS ANY KEY TO CONTINUE ****"
26620 IF INKEY$ = "" GOTO 26620 / LOOP UNTILL ANY KEY IS PRESSED
26635 EFLG = 1 / END OF FILE FLAG EQUALS YES
26640 RETURN        
26800 REM 
26900 PRINT "******  RECORD NUMBER REQUESTED DOES NOT EXIST  ******"
26910 GOTO 8020 / ASK FOR ANOTHER RECORD NUMBER 
27000 REM * READ SCREEN TEST
27005 GOSUB 10900 / PUT PROGRAM DATA DISK IN DEFAULT DRIVE PROMPT
27010 OPEN "I",#1,"SCTEST" / OPEN THE SCREEN TEST FILE AS A SEQUENTIAL ACCESS FILE
27020 FOR T = 1 TO 40
27030 INPUT #1,SCRN(T) / READ CUSTOM SCREEN FLAG FOR EACH FILE
27040 NEXT T
27050 CLOSE #1
27060 RETURN
27070 REM * READ SCREEN DESCRIPTION
27071 GOSUB 10900 / PUT THE PROGRAM DATA DISK IN DEFAULT DRIVE PROMPT
27072 A$ = STR$(A) / CONVERTS FILE NUMBER TO A STRING
27074 A$ = MID$(A$,2) / GETS RID OF LEADING SPACE
27076 A$ = "SCREEN" + A$ / CONCATE "SCREEN" AND FILE NUMBER
27080 OPEN "I",#2,A$ / OPEN SCREEN DESCRIPTION FILE
27090 FOR T = 1 TO 18 
27100 INPUT #2,SW$(T) / INPUT FROM DISK THE 18 OVERLAY LINES
27110 NEXT T
27120 FOR T = 1 TO NREC(A) / START LOOP READING EACH FIELD
27130 INPUT #2,LE(T),CE(T) / INPUT LINE NUMBER AND COLUMN NUMBER FOR EACH FIELD
27140 IF FTY(A,T) = 2 THEN INPUT #2,LEK(T),CEK(T) / IF FIELD IS AN INTEGER THE INPUT THE LINE AND COLUMN TO PRINT THE KEY AT
27150 NEXT T / END LOOP FOR EACH FIELD
27160 INPUT #2,RPT / INPUT REPEATING FIELD OPTION
27170 IF RPT = 2 THEN GOSUB 27200 / IF REPEATING OPTION EQUALS YES THEN GOSUB 
27180 CLOSE #2
27190 RETURN
27200 INPUT #2,LSTE / INPUT THE NUMBER OF THE LAST NON REPEATING FIELD
27210 T2 = LSTE + 1 / T2 EQUALS FIRST REPEATING FIELD
27220 FOR T = T2 TO NREC(A) / FOR ALL THE REPEATING FIELDS
27230 INPUT #2,SUMF(T) / INPUT SUM OPTION
27240 NEXT T
27245 H = 0 / INITIALZE H TO 0 
27250 FOR T = 1 TO LSTE / FOR T = 1 TO LAST NON REPEATING FIELD
27260 H = FL(A,T) + H 
27270 NEXT T
27280 FIELD #1,H AS TEST$ / FIELD THE NOREPEATING FIELDS AS TEST$
27300 RETURN
28000 REM 
28100 GOSUB 13000 / CLEAR SCREEN
28110 PRINT "**********  DO YOU WANT TO USE THE STANDARD OR YOUR CUSTOM SCREEN  **********"
28115 PRINT ""
28120 PRINT "                        1 - USE THE CUSTOM SCREEN"
28125 PRINT ""
28130 PRINT "                        2 - USE THE STANDARD SCREEN"
28135 PRINT ""
28140 PRINT "*******************  ENTER THE NUMBER THEN PRESS RETURN  ********************"
28200 GOSUB 14000 / INPUT INTEGER LESS THEN 100 SUBROUTINE
28210 IF DT# < 1 OR DT# > 2 THEN 28200 / IF OPTION OUT OF RANGE THEN REENTER
28220 CSCR = DT# / CLEAR SCREEN OPTION EQUALS THE VALUE RETURNED FROM THE INPUT SUBROUTINE
28230 IF CSCR = 1 THEN GOSUB 27070 / IF USING THE CUSTOM SCREEN THEN READ THE CUSTOM SCREEN DATA
28300 RETURN
29000 REM * READ IDEX SUBROUTINE
29010 OPEN "I",#1,"IDEX"   
29020 FOR T = 1 TO MAXF / FOR T = 1 TO MAXIMUM FILE NUMBER
29030 INPUT #1,D,D,D,MFLG(T) / INPUT LIMITS FLAG
29040 NEXT T
29050 CLOSE #1
29060 RETURN
29070 REM * READ MAX MIN DATA
29080 A$ = STR$(A) / CONVERT FILE NUMBER TO A STRING
29090 A$ = MID$(A$,2) / GET RID OF LEADING SPACE
29100 A$ = "MAXMIN" + A$ / SET FILE NAME TO "MAXIMIM" + FILE NUMBER
29110 OPEN "I",#2,A$ / OPEN LIMITS DESCRIPTION FILE
29120 FOR T = 1 TO NREC(A) / FOR EACH FIELD
29130 INPUT #2,MAXC#(T),MINC#(T) / INPUT MAXIMUM AND MINIMUM
29140 NEXT T
29150 CLOSE #2
29160 RETURN
29190 N = D 
29200 REM * CHECK MAX LIMITS
29210 IF DT# < MINC#(N) OR DT# > MAXC#(N) THEN GOSUB 29300 / IF NUMBER INPUTED IS OUTSIDE ITS LIMITS THEN GOSUB 29300
29220 RETURN
29300 PRINT CHR$(7) / SOUNDS BUZZER
29310 PRINT CHR$(7) / SOUNDS BUZZER
29329 RETURN
30000 REM * PRINT OVERLAY
30005 GOSUB 20400
30010 OFFSET = 0 / INITIALIZE OFFSET TO 0
30100 FOR T = 1 TO 18
30110 PRINT SW$(T) / PRINT THE OVERLAY LINES
30120 NEXT T
30130 RETURN
31000 REM * PRINT FIELDS
31010 X(N) = I# 
31100 IF LE(N) = 0 THEN RETURN / IF LINE NUMBER = 0 THEN RETURN (DO NOT SHOW FIELD OPTION)
31110 LI = LE(N) + 1 + OFFSET / LINE NUMBER EQUALS STANDARD LINE NUMBER PLUS ONE PLUS THE OFFSET
31115 TB = CE(N) / COLUMN NUMBER
31120 GOSUB 13050 / LOCATE SUBROUTINE
31130 ON FTY(A,N) GOSUB 32000,32100,32100,32100,32200 / ON FIELD TYPE GOSUB
31140 IF KEYLIST(A,N) > 0 THEN GOSUB 33000 / IF THERE IS A KEYLIST GOSUB 33000
31145 IF SUMF(N) = 2 THEN GOSUB 39200 / IF THERE ARE SUMS THEN GOSUB 39200
31150 RETURN
32000 REM STRINGS *
32010 PRINT I$ / PRINT THE STRING
32020 RETURN
32100 PRINT I# / PRINT INTEGERS, SINGLE AND DOUBLE PRECISION
32110 RETURN
32200 REM *$$$$
32210 PRINT USING "**$########.##";I# / PRINT DOLLAR AND CENTS AMOUNT
32220 RETURN
33000 REM * PRINT KEYS
33100 IF LEK(N) = 0 THEN RETURN / IF LINE NUMBER OF KEY EQUALS 0 THEN RETURN
33110 LI = LEK(N) + 1 + OFFSET / LINE NUMBER EQUALS STANDARD LINE NUMBER PLUS 1 PLUS OFFSET
33120 REM
33130 TB = CEK(N) / COLUMN NUMBER
33140 GOSUB 13050 / LOCATE SUBROUTINE
33150 T1 = KEYLIST(A,N) / THE LIST NUMBER FOR THIS FIELD
33160 PRINT L$(T1,I#) / PRINTS OUT THE KEY FOR THIS FIELD
33170 RETURN
34000 REM * PRINT FIELDS
34050 GOSUB 30000
34100 FOR N = 1 TO NREC(A) / START LOOP, FOR EACH FIELD
34102 GOSUB 34110 / CONVERT STRINGS TO NUMBER 
34104 NEXT N
34110 ON FTY(A,N) GOSUB 34200,34300,34500,34600,34600 / ON FIELD TYPE GOSUB
34120 GOSUB 31000 / PRINT FIELD SUBROUTINE
34140 RETURN
34200 I$ =  X$(N)
34250 RETURN  
34300 I#=CVI(X$(N)) / CONVERT STRING TO NUMBER
34310 X(N) = I#
34350 RETURN
34500 I#=CVS(X$(N)) / CONVERT STRING TO NUMBER
34550 RETURN
34600 I#=CVD(X$(N)) / CONVERT STRING TO NUMBER
34610 X(N) = I#
34650 RETURN
35000 REM * PRINT OVERLAY
35010 EFLG = 0 / END OF OVERLAY FLAG = NO
35030 IF RPT = 2 THEN LPRINT "AND SUBRECORDS" ELSE LPRINT "" / IF REPEATING FIELDS THEN PRINT ...
35050 GOSUB 20400 / SET SUMS TO 0
35100 FOR T = 1 TO 18
35110 LPRINT SW$(T); / PRINT OVERLAYS
35115 GOSUB 35200  / PRINT ANY FIELDS ON THIS LINE
35117 IF EFLG = 1 THEN RETURN / IF END OF OVERLAY THEN RETURN
35120 NEXT T
35130 RETURN
35200 REM * LPRINT FIELDS
35210 FOR T2 = 1 TO NREC(A) / FOR ALL FIELDS
35220 IF LE(T2) = T THEN GOSUB 36000 / IF FIELD IS ON THIS LINE GOSUB 36000
35300 IF LEK(T2) = T THEN GOSUB 39000 / IF KEY IS ON THIS LINE GOSUB 39000
35400 NEXT T2
35410 LPRINT ""
35500 RETURN
35600 REM * LPRINT REPEATING FIELDS
35650 GOSUB 20050 / GET UPPER AND LOWER LIMITS 
35655 T3 = LSTE + 1 / FIRST REPEATING FIELD
35657 RN = RNL / RECORD NUMBER = RECORD NUMBER LOWER
35660 FOR TH = RNU TO RNL / FOR ALL RELATED RECORDS
35665 GET #1,TH / GET RECORD NUMBER
35670 FOR N = T3 TO NREC(A) / FOR ALL REPEATING FIELDS
35675 T2 = N 
35680 GOSUB 36100 / PRINT FIELDS
35685 IF SUMF(N) = 2 THEN SUM#(N) = SUM#(N) + I# / IF SUMS FOR THIS FIELD THEN ADD TO SUM
35687 IF FTY(A,N) = 2 AND LEK(N) > 0 THEN GOSUB 39000 / IF THERE ARE KEYLIST AND THEY ARE SHOWN THEN GOSUB 39000
35690 NEXT N / END LOOP ON FIELDS
35700 LPRINT ""
35710 NEXT TH / END LOOP ON RELATED RECORDS
35750 REM * LPRINT SUMS
35755 EFLG = 1 / END FLAG = YES
35760 FOR N = LSTE TO NREC(A) / FOR ALL REPEATING FIELDS
35770 IF SUMF(N) = 2 THEN GOSUB 35900 / IF SUMS ARE SPECIFIED THEN GOSUB 35900
35780 NEXT N 
35790 RETURN
35900 REM 
35905 TB = CE(N) / COLUMN 
35906 LPRINT TAB(TB); / LPRINT OVER TO THE COLUMN
35907 IF FTY(A,N) = 5 THEN GOTO 35950 / IF DOLLAR AND CENTS AMOUNT GOTO 35950
35910 LPRINT TAB(TB) SUM#(N); / PRINT SUM
35920 RETURN
35950 LPRINT USING "**$########.##";SUM#(N); / PRINT DOLLAR AND CENTS SUMS
35960 RETURN
36000 REM * LPRINT FIELDS
36050 N = T2
36060 IF RPT = 2 AND N > LSTE THEN GOTO 35600 / IF THERE ARE REPEATING FIELDS AND THIS FIELD IS ONE OF THEM THEN GOTO 35600
36100 ON FTY(A,T2) GOSUB 34200,34300,34500,34600,34600 / ON FIELD TYPE GOTO
36200 GOTO 37000
37000 REM * PRINT FIELDS
37115 TB = CE(T2) / COLUMN NUMBER
37125 LPRINT TAB(TB) ""; / LPRINT OVER TO THE COLUMN
37130 ON FTY(A,T2) GOSUB 38010,38100,38100,38100,38200 / ON FIELD TYPE GOTO
37150 RETURN
38000 REM STRINGS *
38010 LPRINT I$; PRINT STRINGS
38020 RETURN
38100 LPRINT I#; PRINT NUMBERS 
38110 RETURN
38200 REM * $$$$
38210 LPRINT USING "**$########.##";I#; / PRINT DOLLAR AND CENTS NUMBERS
38220 RETURN
39000 REM  * PRINT KEYS
39010 ON FTY(A,T2) GOSUB 34200,34300,34500,34600,34600 / ON FIELD TYPE GOTO
39090 N = T2
39130 TB = CEK(T2) / COLUMN TO PRINT KEY AT
39140 LPRINT TAB(TB) ""; / PRINT OVER TO THE COLUMN
39150 T1 = KEYLIST(A,T2) / THE LIST NUMBER
39160 LPRINT L$(T1,I#); / PRINT THE KEYLIST
39170 RETURN
39200 REM * PRINT TOTALS
39300 SUM#(N) = SUM#(N) + I# / ADD TO SUM
39310 LI = 19 / LINE 19
39320 GOSUB 13050 / LOCATE SUBROUTINE
39330 IF FTY(A,N) = 5 THEN GOTO 39600 / IF DOLLAR AND CENTS AMOUNT GOTO 39600
39400 PRINT SUM#(N);
39410 RETURN
39600 REM $$$$$
39610 PRINT USING "**$########.##";SUM#(N); / PRINT DOLLAR AND CENTS AMOUNT
39620 RETURN
```

## REMARKS4.BAS

```bas
40000 REM * NEW INPUT
40002 ABORTFLG = 0 / INITIALIZE ABORT FLAG TO 0
40008 IF REALFLG(A) = 2 THEN GOSUB 60200 / IF THERE ARE REALTIME TRANSFERS GOTO OPEN REALTIME FILE SUBROUTINE
40010 GOSUB 13000 / CLEAR SCREEN
40015 IF DATAIN = 1 GOTO 40500 / IF INPUT DESCRIPTION IS ALREADY IN SKIP INPUTTING THE DATA
40017 GOSUB 40020 / GOSUB THE INPUT DATA ROUTINE
40018 GOTO 40500 / SKIP OVER THE INPUT DATA ROUTINE
40020 REM  READ INPUT DATA 
40021 GOSUB 49000 / SET GLOBAL FLAGS TO 0 
40022 GOSUB 10900 / PUT PROGRAM DATA DISK IN DRIVE PROMPT
40025 A$ = STR$(A) / CONVERT THE FILE NUMBER TO A STRING
40027 A$ = MID$(A$,2) / GET RID OF THE LEADING SPACE
40030 N$ = "IPUTD"+A$ / FILE NAME = "IPUTD" PLUS FILE NUMBER
40040 OPEN "I",#2,N$ / OPEN INPUT DATA FILE
40050 INPUT #2,NREC(A) / INPUT NUMBER OF FIELDS IN THIS FILE
40060 FOR N3= 1 TO NREC(A) / FOR EACH FIELD IN THE FILE
40062 N = N3 
40070 INPUT #2,IOPT(N) / GET THE INPUT OPTION NUMBER
40080 ON IOPT(N) GOTO 40090,40120,40150,40210,40240,40270,40430,40370,40370,40430,40430,40430,40210 / ON THE INPUT OPTION GOTO
40085 GOTO 40450 / CUSTOM INPUT OPTIONS FALL THROUGH THE ABOVE GOTO 
40090 REM OPERATOR ENTRY*
40100 INPUT #2,PROMPT$(N) / INPUT THE PROMPT
40110 GOTO 40450
40120 REM GET FROM ANOTHER FILE*
40130 INPUT #2,IFN(N),IFLD(N),IRNFLD(N) / INPUT DATA FROM THIS FILE, FROM THIS FIELD, RECORD NUMBER EQUALS THE VALUE OF THIS FIELD IN THE SOURCE FILE
40132 GFLG(IFN(N)) = 1 / SET GLOBAL FLAG TO YES 
40134 GFLG(IFLD(N)) = 1 / SET GLOBAL FLAG TO YES
40136 GFLG(IRNFLD(N)) = 1 / SET GLOBAL FLAG TO YES
40140 GOTO 40450
40150 REM ADD PREVIOUS FIELDS*
40160 INPUT #2,NOS(N) / INPUT THE NUMBER OF FIELDS TO ADD
40170 FOR T = 1 TO NOS(N) / FOR EACH FIELD TO ADD
40180 INPUT #2,ADDFLD(N,T) / ADD THIS FIELD
40185 GFLG(ADDFLD(N,T)) = 1 / SET GLOBAL FLAG TO YES
40190 NEXT T / END LOOP READING FIELDS TO ADD
40200 GOTO 40450
40210 REM SUBTRACT PREVIOUS FIELDS* / ALSO USED FOR DIVIDE 2 FIELDS
40220 INPUT #2, SUBX(N),SUBY(N) / INPUT THE FIELD NUMBERS TO SUBTRACT
40222 GFLG(SUBX(N)) = 1 / SET GLOBAL FLAG TO YES
40224 GFLG(SUBY(N)) = 1 / SET GLOBAL FLAG TO YES
40230 GOTO 40450
40240 REM MULTIPLY FIELDS*
40250 INPUT #2, MULX(N),MULY(N) / INPUT THE FIELDS TO MULTIPLY
40252 GFLG(MULX(N)) = 1 / SET GLOBAL FLAG TO YES
40254 GFLG(MULY(N)) = 1 / SET GLOBAL FLAG TO YES
40260 GOTO 40450
40270 REM GET FROM A TABLE* / COMPUTE USING TAX TABLE OPTION
40280 INPUT #2,TX(1,N),TX(2,N),TX(3,N),TX(4,N),TX(5,N),TX(6,N) / INPUT DATA FOR COMPUTING TAXES
40282 GFLG(TX(2,N)) = 1 / SET GLOBAL FLAG TO YES
40283 GFLG(TX(4,N)) = 1 / SET GLOBAL FLAG TO YES
40284 GFLG(TX(5,N)) = 1 / SET GLOBAL FLAG TO YES
40285 GFLG(TX(6,N)) = 1 / SET GLOBAL FLAG TO YES
40290 TTBL = 5 / SET TAX TABLE FLAG TO YES
40310 GOTO 40450
40370 REM MAXIMUM* / ALSO USED FOR MINIMUM
40380 INPUT #2,NOS(N) / INPUT THE NUMBER OF ITEMS YOU WANT TO COMPARE
40390 FOR T = 1 TO NOS(N) / FOR ALL FIELDS TO COMPARE
40400 INPUT #2,MAXMIN(N,T) / INPUT THE FIELD TO COMPARE
40405 GFLG(MAXMIN(N,T)) = 1 / SET GLOBAL FLAG TO 1
40410 NEXT T 
40420 GOTO 40450
40430 REM CONSTANT*
40440 INPUT #2,KC(N),CFLD(N) / INPUT THE CONSTANT AND THE FIELD OPERATED ON BY THE CONSTANT
40445 GFLG(CFLD(N)) = 1 / SET GLOBAL FLAG TO YES
40450 NEXT N3   
40460 CLOSE #2 
40470 DATAIN = 1 / SET INPUT DATA IN FLAG TO YES
40480 RETURN
40500 REM OPEN SECOND FILE*
40505 IF TWOOPEN = 1 THEN 40637 / IF SECOND FILE TO INPUT DATA FROM IS ALREADY OPEN THEN SKIP THIS SECTION
40507 TWOOPEN = 1 / SET SECOND FILE OPEN FLAG TO YES
40510 FOR T = 1 TO NREC(A) / FOR EACH FIELD IN THE FILE
40520 IF IOPT(T) = 2 GOTO 40600 / IF INPUT OPTION IS GET DATA FROM ANOTHER FILE THEN OPEN THE SECOND FILE SUBROUTINE
40530 NEXT T 
40540 GOTO 40640
40600 B = IFN(T) / B, THE SECOND FILE EQUALS THE NUMBER OF THE FILE TO GET DATA FROM
40602 AHLD = A / HOLD THE VALUE OF THE FIRST FILE
40604 A = B 
40610 PRINT F$(B), " SECOND FILE FOR CUSTOM INPUT "
40620 GOSUB 2300 / GET DISK DRIVE THE FILE IS ON SUBROUTINE
40625 A = AHLD / RETURN THE VALUE OF AHLD
40630 GOSUB 2550 / OPEN THE SECOND FILE
40635 GOSUB 7950 / GET THE MAXIMUM RECORD NUMBER OF THE SECOND FILE
40637 IF TAXIN = 1 THEN 41000 / IF TAX TABLES ARE ALREADY IN MEMORY THEN SKIP THIS SECTION
40638 TAXIN = 1 / SET TAX TABLE IN MEMORY FLAG TO YES
40640 FOR T = 1 TO NREC(A)
40650 IF IOPT(T) = 6 GOTO 40800 / IF FILE COMPUTES TAX TABLE DATA THEN READ THE TAXSCH FILE
40660 NEXT T
40670 GOTO 41000 / SKIP READING THE TAX TABLES
40800 GOSUB 45000 / GOTO THE SUBROUTINE THAT READS THE TAX TABLES
41000 REM CUSTOM INPUT ROUTINE*  
41010 GOSUB 13000 / CLEAR SCREEN
41012 OFFSET = 0 / INITIALIZE OFFSET TO 0
41014 IF REALFLG(A) = 2 AND RN <= MRN THEN GOSUB 61300 / IF THERE ARE REALTIME TRANSFERS AND YOU ARE OVERWRITING A RECORD THEN CORRECT REALTIME TRANSFER FILE
41015 PRINT "*****************  FILE NAME :";F$(A);"  ";"RECORD NUMBER :";RN;" ****************"
41030 IF CSCR = 1 THEN GOSUB 30000 /IF USING A CUSTOM SCREEN PRINT OVERLAYS
41080 LI = 25 / LINE EQUALS 25
41082 GOSUB 13100 / LOCATE SUBROUTINE
41085 PRINT "[ = SAME AS LAST RECORD , < BACK UP , > ABORT THIS RECORD , ^ EQUALLAST OVER 1]"; / PRINTS MESSAGE AT LINE 25
41087 GOTO 41130 / SKIP THE FOLLOWING SUBROUTINE
41092 LI = 20 / LINE EQUALS 25
41093 GOSUB 13100 / LOCATE SUBRUTINE
41094 PRINT "                                                                              "   / CLEAR LINES 20 TO 24
41095 PRINT "                                                                              "
41096 PRINT "                                                                              "
41097 PRINT "                                                                              "
41100 PRINT "                                                                             "; 
41110 LI = 20 / LINE EQUALS 20
41115 GOSUB 13100 / LOCATE SUBROUTINE
41120 PRINT "ON FIELD NUMBER : ";N;" FIELD NAME : ";FLDN$(A,N);" : " / PRINT FIELD NUMBER AND FIELD NAME
41125 RETURN
41130 N = 1  / INITIALIZE N, THE FIELD NUMBER TO 1
41133 WHILE N <= NREC(A) / WHILE THE FIELD NUMBER IS LESS THEN OR EQUAL TO THE MAXIMUM FIELD NUMBER
41135 REFLG = 0 / INITIALIZE RESTART FLAG TO NO
41137 IF N < 1 THEN N = 1 / FIELD NUMBER CAN'T BE LESS THEN 1
41140 ON IOPT(N) GOSUB 41200,41400,41600,41800,42000,42200,42600,42800,43000,43200,43400,43600,41800,53000,54000,55000,56000,57000,58000,59000 / ON INPUT OPTION GOTO
41150 GOSUB 43800 / GOSUB THE PRINT FIELD ON SCREEN, AND SET FILE BUFFER SUBROUTINE
41155 N = N + 1 / INCREMENT THE FIELD NUMBER
41160 WEND / CONTINUE WITH THE LOOP FOR ALL FIELDS
41165 GOTO 44910
41170 REM * BACK UP FIELDS UNTIL IOPT = 1 / BACK UP UNTILL THERE IS AN OPERATOR ENTRY
41175 N = N - 1 / DECREMENT THE FILE NUMBER
41180 IF N < 1 THEN 41133 / CAN'T DECREMENT PAST ONE
41185 IF IOPT(N) <> 1 THEN 41175 / IF INPUT OPTION IS NOT AN OPERATOR ENTRY THEN DECREMENT AGAIN
41190 GOTO 41133 / CONTINUE ENTERING FIELDS
41200 REM *  OPERATOR ENTRY
41202 NE = 1 / SET NEW ENTRY FLAG TO YES
41205 GOSUB 41092 / CLEAR THE LINES
41210 PRINT PROMPT$(N) / PRINT THE PROMPT
41215 REFLG = 0 / INITIALIZE RESTART FLAG TO 0
41220 IF FTY(A,N) = 1 GOTO 41300 / IF A STRING THEN GOTO 41300
41230 ON FTY(A,N) GOSUB 15000,14100,14200,14300,14300  / ON THE FIELD TYPE GOTO THE INPUT SUBROUTINE FOR THAT FIELD TYPE
41234 IF REFLG = 1 THEN GOTO 41170 / IF RESTART FLAG EQUALS YES THEN RESTART DATA ENTRY
41235 IF ABORTFLG = 1 GOTO 7000  / IF ABORT FLAG EQUALS YES THEN GOTO 7000
41236 IF MFLG(A) = 2 AND FTY(A,N) <> 1 THEN GOSUB 29200 / IF LIMITS FLAG IS YES AND THE FIELD IS NOT A STRING THEN CHECK THE LIMITS
41237 T2 = KEYLIST(A,N) / KEYLIST NUMBER
41238 T3 = MAXK(T2) / MAXIMUM FOR THE LIST
41239 REM  IF KY(A,N) = 2 AND (DT# < 1 OR DT# > T3) GOTO 41230
41240 I# = DT# / SET I# TO THE VALUE ENTERED IN THE SUBROUTINE
41245 NE = 0 / RESET NEW ENTRY FLAG TO NO
41250 RETURN     
41298 REFLG = 0 / RESET RESTART FLAG TO NO
41300 Q = N / FIELD NUMBER ALSO EQUALS Q
41302 GOSUB 15000 / INPUT STRING SUBROUTINE
41303 IF ABORTFLG = 1 GOTO 7000 / IF ABORT FLAG EQUALS YES THEN ABORT
41304 I$ = A$ / SET I$ TO THE VALUE RETURNED FROM THE STRING INPUT SUBROUTINE
41306 NE = 0 / RESET NEW ENTRY FLAG TO NO
41308 IF REFLG = 1 GOTO 41170 / IF RESTART FLAG THEN RESTART DATA ENTRY
41310 RETURN    
41400 REM GET FROM ANOTHER FILE*
41402 FLD = IFLD(N) / GET DATA FROM THIS FIELD
41404 T = IRNFLD(N) / RECORD NUBER OF THE FIELD TO GET DATA FROM
41406 RN2= X(T) / RECORD NUMBER OF FILE 2 EQUALS THE VALUE OF THIS SOURCE FIELD
41407 IF RN2 > MRNS THEN GOTO 48000 / IF RECORD NUMBER OF THE SECOND FILE IS GREATER THEN MAXIMUM RECORD NUMBER THEN GOTO 48000
41408 GET #2,RN2 / GET THE RECORD FROM THE SECOND FILE
41409 B = IFN(N) / B IS THE FILE NUMBER OF THE SECOND OPENED FIELD
41420 ON FTY(B,FLD) GOTO 41422,41460,41500,41550,41550 / ON THE FIELD TYPE OF THE FIELD IN THE SECOND FILE GOTO
41422 I$ = Y$(FLD) / SET I$ TO THE VALUE OF THE FIELD
41430 RETURN      
41460 Y$ = Y$(FLD) 
41465 I% = CVI(Y$) / CONVERT FIELD TO A NUMBER
41467 I# = I%
41470 RETURN     
41500 I! = CVS(Y$(FLD)) / CONVERT FIELD TO A NUMBER
41505 I# = I!
41510 RETURN     
41550 I# = CVD(Y$(FLD)) / CONVERT FIELD TO A NUMBER
41560 GOTO 43800
41600 REM ADD PREVIOUS FIELDS*
41605 I# = 0 / INITIALIZE TO 0
41610 FOR T = 1 TO NOS(N) / FOR ALL THE FIELDS TO  ADD
41620 T2 = ADDFLD(N,T) / T2 IS THE FIELD TO  ADD
41630 I# = I# + X(T2) / ADD THE VALUE TO THE FIELD TO THE PREVIOUS SUM
41640 NEXT T / END LOOP OF FIELDS TO ADD
41650 RETURN    
41800 REM SUBTRACT FIELDS
41810 T1 = SUBX(N) / T1 IS FIELD TO SUBTRACT FROM OR DIVIDE INTO
41820 T2 = SUBY(N) / T2 IS FIELD TO SUBTRACT OR DIVIDE BY 
41830 IF IOPT(N) = 4 THEN I# = X(T1) - X(T2) ELSE I# = X(T1)/X(T2) / EITHER SUBTRACT OR DIVIDE DEPENDING ON THE INPUT OPTION
41840 RETURN    
42000 REM MULTIPLY FIELDS
42010 T1 = MULX(N) / FIRST FIELD TO MULTIPLY
42020 T2 = MULY(N) / SECOND FIELD TO MULTIPLY
42030 I# = X(T1) * X(T2) / MULTIPLY FIELDS
42040 RETURN     
42200 REM GET FROM A TABLE
42210 ON TX(1,N) GOSUB 42400,42450 / IF TAX TABLE IS CONSTANT GOSUB 42400, IF TAX TABLE VARIES GOSUB 42450
42220 ON TX(3,N) GOSUB 42500,42550 / IF PAY PERIOD CONSTANT GOSUB 42500 IF PAY PERIOD VARIES GOSUB 42550
42230 Y = TX(5,N) / MARRIED SINGLE FIELD EQUALS THIS FIELD
42240 MSS = X(Y) / MARRIED SINGLE FIELD
42250 Y = TX(6,N) / PAY EQUALS THIS FIELD
42260 PAY# = X(Y) / PAY
42270 GOSUB 45500 / COMPUTE TAX SUBROUTINE
42272 I# = TTAX# / SET I# TO TTAX# RETURNED FROM COMPUTE TAX SUBROUTINE
42290 RETURN     
42400 FSS = TX(2,N) / FEDERAL STATE TAX TABLE NUMBER CONSTANT 
42410 RETURN
42450 Y = TX(2,N)
42460 FSS = X(Y) /FEDERAL STATE TAX TABLE NUMBER EQUALS THE VALUE OF THIS FIELD
42470 RETURN
42500 PPS = TX(4,N) / PAY PERIOD CONSTANT 
42510 RETURN
42550 Y = TX(4,N)
42560 PPS = X(Y) / PAY PERIOD EQUALS THIS FIELD
42570 RETURN
42600 REM CONSTANT
42610 I# = KC(N) / FILED EQUALS A CONSTANT
42620 RETURN    
42800 REM MAXIMUM
42802 T2 = MAXMIN(N,1) / T2 IS THE FIRST FIELD TO COMPARE
42804 I# = X(T2) / INITIALIZE MAXIMUM VALUE TO THE VALUE OF THE FIRST FIELD TO COMPARE
42810 FOR T = 2 TO NOS(N) / FOR THE REST OF THE FIELDS TO COMPARE
42820 T2 = MAXMIN(N,T) / NEXT FIELD TO COMPARE
42830 IF X(T2) > I# THEN I# = X(T2) / IF THE VALUE OF THIS FIELD IS GREATER THEN THE MAXIMUM LET THE MAXIMUM EQUAL THE FIELD
42840 NEXT T
42850 RETURN        
43000 REM MINIMUM*
43002 T2 = MAXMIN(N,1) / FIRST FIELD TO COMPARE
43004 I# = X(T2) / INITIALIZE MINIMUM TO THE VALUE OF THE FIRST FIELD
43010 FOR T = 2 TO NOS(N) / FOR THE REST OF THE FIELDS TO COMPARE
43020 T2 = MAXMIN(N,T) / NEXT FIELD TO COMPARE 
43030 IF X(T2) < I#  THEN I# = X(T2) / IF THE VALUE OF THE FIELD IS LESS THEN THE MINIMUM THEN LET THE MINIMUM EQUAL THE VALUE OF THIS FIELD
43040 NEXT T 
43050 RETURN       
43200 REM MULTIPLY BY A CONSTANT*
43210 T = CFLD(N) / T IS THE FIELD TO MULTIPLY THE CONSTANT BY
43220 I# = KC(N) * X(T) / MULTIPLY THE CONSTANT BY THE VALUE OF FIELD T
43230 RETURN    
43400 REM ADD A CONSTANT*
43410 T = CFLD(N) /  T IS THE FIELD TO ADD THE CONSTANT TO
43420 I# = KC(N) + X(T) / ADD THE CONSTANT AND THE FIELD
43430 RETURN    
43600 REM SUBTRACT A CONSTANT
43610 T = CFLD(N) / T IS THE FIELD TO SUBTRACT THE CONSTANT FROM
43620 I# = X(T) - KC(N) / SUBTRACT THE CONSTANT FROM THE VALUE OF FIELD T
43630 RETURN     
43800 REM LSET
43810 ON FTY(A,N) GOTO 43900,44000,44100,44200,44200 / ON FIELD TYPE GOTO
43900 REM STRING*
43910 LSET X$(N) = I$ / PUT STRINGS IN THE FILE BUFFER
43920 CK$(N) = I$ / HOLD THE STING AS CK$(FIELD NUMBER)
43990 GOTO 44500
44000 REM INTEGER *           
44020 LSET X$(N) = MKI$(I#) / PUT INTERGERS IN FILE BUFFER
44030 GOTO 44500
44100 REM SINGLE PRECISION* 
44110 I! = I#
44120 LSET X$(N) = MKS$(I#) / PUT SINGLE PRECISION NUMBERS IN FILE BUFFER
44130 GOTO 44500
44200 REM DOUBLE PRECISION*
44210 LSET X$(N) = MKD$(I#) / PUT DOUBLE PRECISON NUMBERS IN FILE BUFFER
44500 IF CSCR = 1 THEN GOSUB 31000 / IF USING A CUSTOM SCREEN THEN PRINT THE FIELD ON THE SCREEN USING THE 31000 SUBROUTINE
44501 IF CSCR = 1 THEN GOTO 44900 / IF USING A CUSTOM SCREEN THEN SKIP THE FOLLOWING SECTION
44502 IF N < 19 THEN HT = N + 1 / IF THE FIELD NUMBER IS LESS THEN 19 THEN THE LINE NUMBER IS THE FIELD NUMBER PLUS ONE
44503 IF N >= 19 THEN HT = N MOD 18 + 2 / IF THE FIELD NUMBER IS EQUAL OR GREATER THEN 19 THEN THE LINE NUMBER IS N MOD 18 + 2
44504 LI = HT / LINE NUMBER
44505 GOSUB 13100 / LOCATE SUBROUTINE
44506 IF N <18 GOTO 44510 / IF FIELD NUMBER LESS THEN 18 SKIP THE NEXT 2 LINES
44507 PRINT "                                                                              "; / CLEAR LINE
44508 GOSUB 13100 / LOCATE
44510 PRINT N;TAB(5) FLDN$(A,N); / PRINT THE FIELD NUMBER AND THE FIELD NAME
44515 IF KEYLIST(A,N) > 0 GOTO 44800 / IF THERE IS A KEYLIST GOTO 44800
44520 IF FTY(A,N) = 1 GOTO 44600 / IF FIELD IS A STRING GOTO 44600
44525 IF FTY(A,N) = 5 GOTO 44700 / IF FIELD IS A DOLLAR AND CENTS AMOUNT GOTO
44530 PRINT TAB(25) I# / PRINT THE VALUE OF THE FIELD
44535 X(N) = I# / HOLD THE VALUE OF THE FIELD AS X(FIELD NUMBER)
44540 GOTO 44900
44600 PRINT TAB(26) I$ / PRINT STRING FIELDS
44610 GOTO 44900
44700 PRINT TAB(26);
44710 PRINT USING "**$########.##";I# / PRINT DOLLAR AND CENTS AMOUNTS
44715 X(N) = I# / HOLD THE VALUE OF THIS FIELD AS X(N)
44720 GOTO 44900
44800 REM KEYLIST
44810 T1 = KEYLIST(A,N) / THE LIST NUMBER
44820 W$ = L$(T1,I#) / THE KEYLIST TO PRINT
44830 PRINT TAB(25) I#;
44835 X(N) = I# / HOLD THE NUMBER AS X(FIELD)
44840 PRINT TAB(30) "key  ";W$ / PRINT THE KEYLIST
44900 RETURN 
44910 PUT #1,RN / PUT THE FILE BUFFER ON THE DISK
44912 IF REALFLG(A) = 2 THEN GOSUB 60300 / IF THERE ARE REALTIME TRANSFERS THEN UPDATE THE REALTIME TRANSFER FILE
44913 IF REALFLG(A) = 2 AND RN <= MRN THEN GOSUB 61400 / IF THERE ARE REALTIME TRANSFERS AND YOU ARE OVERWRITING A OLD FILE THEN CORRECT REALTIME FILE
44915 IF RN > MRN THEN MRN = RN / IF RECORD NUMBER EXCEEDS THE MAXIMUM RECORD NUMBER THEN LET THE MAXIMUM RECORD EQUAL THE RECORD NUMBER
44920 LI = 20 / LINE NUMBER 20
44925 GOSUB 13100 / LOCATE SUBROUTINE 
44930 PRINT "***********************  OPTIONS :  ************************                  "
44940 PRINT "   1 - ENTER NEXT RECORD          3 - CORRECT THIS RECORD                     "
44950 PRINT "   2 - ENTER ANOTHER RECORD       4 - ENTER A SUBRECORD                       "
44960 PRINT "***************  0 - RETURN TO FILE OPTIONS   **************                  "
44962 SPRT = 5 / SURPRESS PRINTING AFTER OPTION IS ENTERED
44965 GOSUB 14000 / INPUT INTEGER LESS THEN 100 SUBROUTINE
44967 IF DT# <0 OR DT# >4 GOTO 44920 / IF OUT OF RANGE REENTER
44970 TH = DT# / TH EQUALS THE VALUE RETURNED FROM THE INPUT SUBROUTINE
44975 IF TH = 2 THEN RETURN / ENTER ANOTHER RECORD 
44980 IF TH = 0 THEN GOTO 3010 / BACK TO FILE OPTIONS
44985 IF TH = 3 THEN GOSUB 9000 / CORRECT A RECORD SUBROUTINE
44987 IF TH = 3 THEN GOTO 44920 / AFTER CORRECTION GET ANOTHER OPTION
44988 IF TH = 4 AND RPT <> 2 THEN 44996 / IF REQUEST FOR ENTER A SUBRECORD AND SUBRECORDS ARE NOT SET UP ON THE FILE GOTO 44996
44989 IF TH = 4 THEN GOTO 52000 / ENTER A SUBRECORD OPTION
44990 RN = RN + 1 / INCREMENT RECORD NUMBER
44995 GOTO 41000 / ENTER NEXT RECORD
44996 LI = 24 / LINE 24
44997 GOSUB 13100 / LOCATE SUBROUTINE
44998 PRINT TAB(10) "SUBRECORDS ARE NOT SET UP ON THIS FILE";
44999 GOTO 44920 / ASK FOR ANOTHER OPTION
45000 REM 
45001 IF HDISK = 2 THEN GOTO 45010 / IF HARD DISK OPTION THEN SKIP THE PROMPT
45002 GOSUB 13000 / CLEAR SCREEN
45004 PRINT "      PUT THE FLOPPY DISK WITH THE TAX SCHEDULE ON IT IN"
45005 PRINT "                IN THE DEFAULT DISK DRIVE "
45006 PRINT ""
45007 PRINT "         ****  THEN PRESS ANY KEY TO CONTINUE  ****   "
45008 IF INKEY$ = "" THEN GOTO 45008 / LOOP UNTILL ANY KEY IS PRESSED
45010 OPEN "R",#3,"TAXSCH",82 / OPEN THE TAX SCHEDULE FILE
45015 FIELD #3,40 AS D$,2 AS FD$,2 AS PP$,2 AS MS$,8 AS MIN$,8 AS MAX$,8 AS TX$,4 AS PCT$,8 AS OVR$ / FIELD THE TAX SCHEDULE FILE
45018 GOSUB 7900 / GET THE MAXIMUM RECORD NUMBER OF THE FILE
45020 FOR T7 = 1 TO 1000 / START LOOP READING RECORDS
45040 IF T7 > MRN2 GOTO 45160 / IF END OF FILE JUMP OUT OF THE LOOP
45050 GET #3,T7 / GET THE RECORD NUMBER
45070 FS(T7) = CVI(FD$) / CONVERT FEDERAL STATE NUMBER
45080 PP(T7) = CVI(PP$) / CONVERT PAY PERIOD NUMBER
45090 MS(T7) = CVI(MS$) / CONVERT MARRIED SINGLE NUMBER
45100 MIND#(T7) = CVD(MIN$) / CONVERT MINIMUM PAY FOR RATE
45110 MAXD#(T7) = CVD(MAX$) / CONVERT MAXIMUM PAY FOR RATE
45120 TAX#(T7) = CVD(TX$) / CONVERT BASE TAX
45130 PCT!(T7) = CVS(PCT$) / CONVERT PECENT OVER 
45140 OVR#(T7) = CVD(OVR$) / CONVERT OVER THIS PAY
45150 NEXT T7 / END LOOP READING TAX RECORDS
45160 REM
45170 GOTO 45200
45200 REM
45210 TMAX = T7 - 1 / MAXIMUM TAX RECORD NUMBER
45215 CLOSE #3 / CLOSE TAX SCHEDULE FILE
45218 TTBL = 5 / FLAG, TAX TABLE IN MEMORY
45220 RETURN
45230 REM
45240 REM
45250 REM
45260 REM
45270 REM
45500 REM
45510 FOR T7 = 1 TO TMAX / START LOOP READING ALL TAX RECORDS FROM MEMORY
45520 IF FS(T7) = FSS THEN GOTO 45530 ELSE GOTO 45610 / IF FEDERAL STATE NUMBERS MATCH THEN CHECK NEXT FIELD ELSE RECORD DOES NOT MATCH
45530 IF PP(T7) = PPS THEN GOTO 45540 ELSE GOTO 45610 / IF PAY PERIODS MATCH THEN CHECK NEXT FIELD ELSE RECORD DOES NOT MATCH
45540 IF MS(T7) = MSS THEN GOTO 45550 ELSE GOTO 45610 / IF MARRIED SINGLE NUMBER MATCH THEN CHECK NEXT FIELD ELSE RECORD DOES NOT MATCH
45550 IF PAY# < MIND#(T7) GOTO 45610 / IF PAY IS LESS THEN MINIMUM FOR THIS TAX BRACKET THEN RECORD DOES NOT MATCH
45560 IF PAY# > MAXD#(T7) GOTO 45610 / IF PAY IS GREATER THEN THE MAXIMUM FOR THIS TAX BRACKET THEN RECORD DOES NOT MATCH
45570 PAYEX# = PAY# - OVR#(T7) / PAY OVER BASE TAX RATE
45580 TXE# = PAYEX# * PCT!(T7) / 100    / TAX ON PAY OVER BASE TAX RATE
45590 TTAX# = TAX#(T7) + TXE# / TOTAL TAX 
45600 GOTO 45680 
45610 NEXT T7 / CHECK NEXT RECORD
45620 PRINT "++++++  PROPER TAX TABLE NOT FOUND  ++++++" / IF TAX TABLE NOT FOUND THIS IS SHOWN ON THE SCREEN
45630 PRINT "CHECK : FEDERAL OR STATE NUMBER ";FSS
45640 PRINT "        PAY PERIOD NUMBER       ";PPS
45650 PRINT "        MARRIED/SINGLE NUMBER   ";MSS
45660 PRINT "        PAY                     ";PAY
45670 PRINT "*****  PRESS ANY KEY TO CONTINUE  ******"
45672 IF INKEY$ = "" GOTO 45672 / STAY HERE UNTILL A KEY IS PRESSED
45674 GOTO 3010 / BACK TO FILE OPTIONS
45680 REM RETURNS TTAX*
45690 RETURN 
46000 REM CROSS CHECK FIELD
46010 IF DATAIN >< 1 THEN GOSUB 40020 / IF INPUT OPTIONS ARE NOT IN MEMORY THEN GET THEM
46020 REM
46030 REM
46100 GET #1,RN / GET THE RECORD FROM THE DISK
46130 FOR N2= 1 TO NREC(A) / FOR ALL FIELDS IN THE RECORD
46133 N = N2
46135 REM
46140 ON IOPT(N) GOSUB 46200,46200,41600,41800,42000,46200,42600,42800,43000,43200,43400,43600,41800,53000,54000,55000,56000,57000,58000,59000 / ON INPUT OPTION GOSUB 
46145 IF CALFLG = 5 THEN 46160 / IF USING THE RECALCULATION OPTION THEN SKIP THE NEXT LINE
46150 GOSUB 43800
46160 NEXT N2 / END OF LOOP ON FIELDS
46162 PUT #1,RN / PUT THE RECORD ON DISK
46165 RETURN    
46200 ON FTY(A,N) GOTO 46220,46300,46400,46500,46500 / ON FIELD TYPE GOTO. THIS IS A DUMMY RECALCULATION FOR GET FROM ANOTHER FILE OPTION AND COMPUTE USING TAX TABLE OPTION 
46220 I$ = X$(N) / EQUAL TO OLD VALUE
46230 RETURN
46300 I% = CVI(X$(N)) / EQUAL TO OLD VALUE
46310 I# = I%
46320 RETURN
46400 I! = CVS(X$(N)) / EQUAL TO OLD VALUE
46410 I# = I!
46420 RETURN
46500 I# = CVD(X$(N)) / EQUAL TO OLD VALUE
46510 RETURN
47000 REM
47050 CALFLG = 5 / USING THE RECALCULATION OPTION FLAG
47100 GOSUB 13000 / CLEAR SCREEN
47110 PRINT "*******  RECALCULATE THE FIELDS IN A FILE OPTION  *******"
47120 PRINT ""
47130 PRINT "         Use only if you know what you are doing "
47140 PRINT ""
47150 PRINT "MINIMUM RECORD NUMBER : 1   MAXIMUM RECORD NUMBER : ";MRN
47160 PRINT ""
47190 PRINT "***********  DO YOU WANT TO USE THIS OPTION  ************"
47200 PRINT "          1 - NO, RETURN TO FILE OPTION"
47300 PRINT "          2 - YES, I WANT TO USE THIS OPTION "
47310 PRINT "*********  Enter the number then Press Return  **********"
47320 GOSUB 14000 / INPUT INTEGER LESS THEN 100 SUBROUTINE
47330 IF DT# < 1 OR DT# > 2 THEN 47320 / IF OUT OF RANGE THEN REENTER
47340 IF DT# = 1 THEN 3010 / BACK TO FILE OPTIONS
47400 FOR RN = 1 TO MRN / FOR ALL RECORDS
47430 GOSUB 46000 / RECALCULATE THEN
47450 NEXT RN
47470 GOTO 3010 / BACK TO FILE OPTIONS
48000 REM
48100 REM / TRIED TO GET TO LARGE A RECORD FROM THE FILE OPTIONS
48110 PRINT " ++++++  ERROR   +++++++"
48120 PRINT "RECORD NUMBER  ";RN2;" IN FILE ";F$(B);" DOES NOT EXIST"
48140 PRINT "YOU PROBABLY ENTERED FIELD ";IRNFLD(N);" WRONG"
48160 PRINT "*********  PRESS ANY KEY TO CONTINUE  ********"
48170 IF INKEY$ = "" GOTO 48170
48180 GOTO 40000 / START NEW ENTRY OVER AGAIN
49000 REM * SET GFLG TO ZERO  / IF A GLOBAL FLAG DOES NOT EQUAL 0 THEN IT IS USED IN THE CALCULATION OF ANOTHER FIELD
49100 FOR T = 1 TO 28 / SETS GLOBAL FLAGS TO 0 FOR ALL FIELDS
49110 GFLG(T) = 0
49120 NEXT T
49130 RETURN
50000 REM INTRO
50010 GOSUB 13000 / CLEAR SCREEN
50100 PRINT "                  M A I N     P R O G R A M    3.0   "
50105 PRINT ""
50110 PRINT "         Copyright 1984 by Potomac Pacific Engineering Inc."
50120 PRINT ""
50130 PRINT "This program is licensed FREE to all users with some restrictions "
50140 PRINT "YOU MUST READ THE LICENSE CONDITIONS PROIR TO USING THIS PROGRAM"
50165 PRINT "        See the manual for more information on the license."
50167 PRINT ""
50950 PRINT "*****************  PRESS ANY KEY TO CONTINUE  ******************";
50960 IF INKEY$ = "" GOTO 50960 / LOOP UNTILL ANY KEY IS PRESSED
50970 RETURN
51000 REM *******  DONE
51100 CLOSE
51105 GOSUB 13000 / CLEAR SCREEN
51110 PRINT " -BYE, Have a nice Day
51120 END  / EXITS PROGRAM 
52000 REM *  SUB RECORD INPUT
52010 LI = 1 / LINE ONE
52020 GOSUB 13100 / LOCATE SUBROUTINE
52030 PRINT TAB(60) "ON SUBRECORD ";(RN+1) 
52100 OFFSET = OFFSET + 1 / INCREMENT OFFSET FOR EACH SUBRECORD
52110 RN = RN + 1 / INCREMENT RECORD NUMBER
52115 IF REALFLG(A) = 2 AND RN <= MRN THEN GOSUB 61300 / IF THERE ARE REALTIME TRANSFERS AND YOU ARE OVER WRITING A RECORD THEN CORRECT REALTIME TARGET FILE
52120 T2 = LSTE + 1 / FIRST REPEATING FIELD IS T2
52130 FOR N = T2 TO NREC(A) / FOR ALL RECORD NUMBERS
52135 REFLG = 0 / RESTART FLAG SET TO NO
52140 ON IOPT(N) GOSUB 41200,41400,41600,41800,42000,42200,42600,42800,43000,43200,43400,43600,41800,53000,54000,55000,56000,57000,58000,59000 / ON INPUT OPTION GOTO
52150 GOSUB 43800 / PRINT ON SCREEN 
52160 NEXT N  / END LOOP ON FIELDS
52165 GOTO 44910 / PUT DATA ON DISK AND GET NEXT OPTION
53000 REM  SPACE FOR CUSTOM INPUT OPTION # 14
53990 RETURN
54000 REM  SPACE FOR CUSTOM INPUT OPTION # 15
54990 RETURN
55000 REM SPACE FOR CUSTOM INPUT OPTION # 16
55990 RETURN
56000 REM SPACE FOR CUSTOM INPUT OPTION # 17
56990 RETURN
57000 REM SPACE FOR CUSTOM INPUT OPTION # 18
57990 RETURN
58000 REM SPACE FOR CUSTOM INPUT OPTION # 19
58990 RETURN
59000 REM SPACE FOR CUSTOM INPUT OPTION # 20
59990 RETURN
60000 REM *READ REALTIME OPTIONS
60010 OPEN "I",#1,"REALTIME" / OPEN REALTIME FILE
60020 FOR T = 1 TO MAXF
60030 INPUT #1,REALFLG(T) / FOR EACH FILE READ THE REALTIME OPTION
60040 NEXT T
60050 CLOSE #1
60060 RETURN
60070 REM * READ REALTIME DATA
60080 A$ = STR$(A) / CONVERT FILE NUMBER TO A STRING
60090 A$ = MID$(A$,2) / GET RID OF LEADING SPACE
60100 A$ = "REAL" + A$ / CONCATE "REAL" AND THE FILE NUMBER
60110 OPEN "I",#3,A$ / OPEN THE REALTIME DATA FILE FOR THIS FILE
60120 INPUT #3,TFILE,FLD1,FLD2,TFLD1,TFLD2,TFLD3,TFLD4,ADSUB1,ADSUB2,ADSUB3,ADSUB4,TGTRN / INPUT THE REALTIME DATA
60130 CLOSE #3 
60140 RETURN
60200 REM * OPEN REALTIME FILE
60202 IF ROPEN = 5 THEN RETURN / IF THE REALTIME TARGET FILE IS ALREADY OPEN THEN RETURN
60205 GOSUB 13000 / CLEAR SCREEN
60210 AHLD = A / HOLD A
60220 A = TFILE
60230 C = TFILE
60235 PRINT F$(C);"   FILE FOR REALTIME TRANSFER "
60240 GOSUB 2300 / GET THE DISK DRIVE THE REALTIME FILE IS ON
60245 C = TFILE
60250 GOSUB 2580 / OPEN AS FILE 3 
60260 A = AHLD
60265 ROPEN = 5 / SET OPEN FLAG TO YES
60270 RETURN
60300 REM * PUT DATA ON REALTIME FILE
60310 IF REALFLG(A) >< 2 THEN RETURN / IF REALTIME TRANSFERS NOT SPECIFIED THEN RETURN
60330 REM *** CONTINUE
60340 IF ROPEN < 5 THEN GOSUB 60200 / IF REATIME TARGET FILE IS NOT OPEN THEN OPEN
60400 T3 = X(TGTRN) / THE TARGET RECORD NUMBER
60410 GET #3,T3 / GET THE TARGET RECORD NUMBER
60415 IF CTK = 5 THEN 60600 / IF CORRECT FLAG THEN 60600
60420 T1# = CVD(Z$(TFLD1)) / THE TARGEST FILE INITIAL VALUE
60430 T2# = X(FLD1) / THE VALUE TO ADD TO THE TARGET FILE
60440 IF ADSUB1 = 2 THEN T2# = -1 * T2# / IF SUBTRACT OPTION THEN CHANGE TO A NEGITIVE
60450 LSET Z$(TFLD1) = MKD$(T1# + T2#) / ADD AND PUT RESULT IN FILE BUFFER
60460 IF TFLD2 = 0 THEN 60600 / IF NO SECOND TRANSFER 
60520 T1# = CVD(Z$(TFLD2)) / VALUE OF TARGET FIELD
60540 IF ADSUB2 = 2 THEN T2# = -1 * T2# / IF SUBTRACT OPTION THEN MAKE NEGITIVE
60550 LSET Z$(TFLD2) = MKD$(T1# + T2#) / ADD AND PUT SUM IF FILE BUFFER
60600 REM * SECOND TRANSFER
60605 IF CTK = 4 THEN 60900 / IF DO NOT CORRECT THIS TRANSFER FLAG
60610 IF FLD2 = 0 THEN 60900 / IF NO SECOND TRANSFER
60620 T1# = CVD(Z$(TFLD3)) / INITIAL VALUE OF TRANSFER FIELD
60630 T2# = X(FLD2) / SOURCE FIELD
60640 IF ADSUB3 = 2 THEN T2# = -1 * T2# / IF SUBTRACT OPTION THEN MAKE NEGITIVE
60650 LSET Z$(TFLD3) = MKD$(T1# + T2#) / ADD AND PUT SUM IF FILE BUFFER
60660 IF TFLD4 = 0 THEN 60900 / IF NO SECOND TRANSFER
60720 T1# = CVD(Z$(TFLD4)) / INITIAL VALUE OF TARGER FIELD
60740 IF ADSUB4 = 2 THEN T2# = -1 * T2# / IF SUBTRACT OPTION THEN MAKE NEGITIVE
60750 LSET Z$(TFLD4) = MKD$(T1# + T2#) / ADD PUT SUM IN FILE BUFFER
60900 PUT #3,T3 / PUT TARGET RECORD ON DISK
60920 CTK = 1 / RESET CORRECT FLAG TO NO
60980 RETURN
61000 REM *  CORECT DATA ON REALTIME FILE
61050 CTK = 4 / SET CORRECT FLAG 
61060 XHLD1 = X(N) / HOLD X
61100 X(N) = I# - X(N) / DIFFERENCE BETWEEN OLD VALUE AND CORRECTION
61120 GOSUB 60300 / UPDATE REALTIME FILE
61130 X(N) = XHLD1 / RETURN VALUE OF X
61140 RETURN
61200 XHLD1 = X(N) / HOLD X
61205 X(N) = I# - X(N) / DIFFERENCE BETWEEN OLD VALUE AND CORRECTION
61215 CTK = 5 / SET CORRECT FLAG
61220 GOSUB 60300 / UPDATE REALTIME FILE
61230 X(N) = XHLD1 / RETURN VALUE OF X
61240 RETURN
61300 REM * CORRECT REALTIME FILE FOR OVERWRITE
61330 GET #1,RN / GET OLD RECORD
61340 X1# = CVD(X$(FLD1)) / TRANSFERED FIELD 1
61350 X2# = CVD(X$(FLD2)) / TRANSFERED FIELD 2
61355 X3# = CVI(X$(TGTRN)) / OLD TARGET RECORD NUMBER
61360 RETURN
61400 REM ***
61410 XHLD1 = X(FLD1) / HOLD
61420 XHLD2 = X(FLD2) / HOLD
61425 XHLD3 = X(TGTRN) / HOLD
61430 X(FLD1) = -X1# / NEGITIVE OLD VALUE
61440 X(FLD2) = -X2# / NEGITIVE OLD VALUE
61445 X(TGTRN) = X3# / OLD TARGER FIELD
61450 GOSUB 60300 / CORRECT OLD TARGER FIELD 
61460 X(FLD1) = XHLD1 / REPLACE HELD VALUE
61470 X(FLD2) = XHLD2 / REPLACE HELD VALUE
61475 X(TGTRN) = XHLD3 / REPLACE HELD VALUE
61480 RETURN
```

{% comment %}samples_end{% endcomment %}

### Directory of PC-SIG Library Disk #0215

     Volume in drive A has no label
     Directory of A:\

    ACCTSUM            638   1-01-80
    ARSUMARY           616   1-01-80
    ASCIDATA           256   3-10-83   1:58a
    BILL               256   1-01-80
    CHECKS             256   1-01-80
    CLS      OBJ        98   1-01-80
    CTEMP    BAS       256   1-01-80
    CUSTOMER           536   3-10-83  12:54a
    EXTRA             6784   1-01-80
    FFILE             3328   1-01-80
    FORMLIST           128   1-01-80
    IDEX               384   1-01-80
    INVOICE           1504   1-01-80
    IPUTD              128   5-19-28   3:50a
    IPUTD1             512   5-19-28   4:01a
    IPUTD10            256   5-19-28  12:34a
    IPUTD11            640   5-19-28   1:01a
    IPUTD12            384   5-19-28   1:10a
    IPUTD13            256   1-01-80
    IPUTD14            512   5-19-28   1:28a
    IPUTD15            128   1-01-80
    IPUTD2             384   1-01-80
    IPUTD3             384   5-19-28  12:22a
    IPUTD4             896   5-19-28   2:57a
    IPUTD5             384   5-19-28  12:27a
    IPUTD6             384   5-19-28   2:13a
    IPUTD7             384   1-01-80
    IPUTD8             256   5-19-28   2:07a
    IPUTD9             384   5-19-28   1:36a
    JOBCOSTS           168   3-10-83  12:08a
    JOURNAL            924   1-01-80
    KEYLISTS           578   1-01-80
    KYLIST             128   3-10-83  12:50a
    LCATE    OBJ        86   1-01-80
    MASTER   TXT    153216   1-01-80
    MAXMIN1            128   1-01-80
    MAXMIN8            128   1-01-80
    PAYCHECK          1504   3-10-83  12:15a
    PAYCHKS           2898   1-01-80
    PAYSUM            1505   3-10-83  12:33a
    PRINTMAN BAS       896   1-01-80
    PRTEXTRA BAS       640   1-01-80
    READ     ME       2988   1-01-85  12:18p
    REAL1              128   1-01-80
    REAL3              128   1-01-80
    REALTIME           128   1-01-80
    RECIEABL           248   1-01-80
    REMARKS1 BAS     19200   2-13-80  12:01a
    REMARKS2 BAS     28672   2-13-80  12:01a
    REMARKS3 BAS     11392   2-13-80  12:02a
    REMARKS4 BAS     28288   2-13-80  12:03a
    SCREEN1            384   1-01-80
    SCREEN14           512   1-01-80
    SCREEN4            256   1-01-80
    SCREEN6            128   1-01-80
    SCREEN8            256   1-01-80
    SCTEST             128   1-01-80
    SECOND             256   1-01-80
    STOCK              312   1-01-80
    TAXSCH            1312   3-10-83   1:44a
    TEMP     BAS       512   1-01-80
    TEST               812   1-01-80
    TESTIPUT           168   2-13-80  12:31a
    TESTTWO            176   3-10-83  12:39a
    TFER               256   1-01-80
    W2                 384   1-01-80
           66 file(s)     281135 bytes
                               0 bytes free
