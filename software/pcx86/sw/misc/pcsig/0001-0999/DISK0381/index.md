---
layout: page
title: "PC-SIG Diskette Library (Disk #381)"
permalink: /software/pcx86/sw/misc/pcsig/0001-0999/DISK0381/
machines:
  - id: ibm5160
    type: pcx86
    config: /machines/pcx86/ibm/5160/cga/256kb/machine.xml
    diskettes: /machines/pcx86/diskettes.json,/disks/pcsigdisks/pcx86/diskettes.json
    autoGen: true
    autoMount:
      B: "PC-SIG Library Disk #0381"
    autoType: $date\r$time\rB:\rDIR\r
---

{% include machine.html id="ibm5160" %}

{% comment %}info_begin{% endcomment %}

## Information about "BASIC AIDS NO 4"

    The BASICAID program will compress a BASIC program (by removing extra
    spaces, etc.), expand a program, and generate a cross reference of
    BASIC reserved words.  The TBASIC program allows the creation and
    execution of TINY BASIC programs.  TINY BASIC is a limited version of
    the BASIC language.  Included is an internal TINY BASIC editor.
    
    System Requirements: Some programs require BASIC
    
    How to Start:  Type BASICAID or TBASIC and press <ENTER> to start
    either program.  To read DOC files, enter TYPE filename.ext and press
    <ENTER>.
    
    Suggested Registration:  $10.00
    
    File Descriptions:
    
    BASICAID BAS  BASIC source file for BASICAID.EXE
    BASICAID EXE  Multi-fuction BASIC programmers utility
    BASICAID DOC  Documentation for BASICAID.EXE
    TBASIC   COM  TINY BASIC language. A very limited subset of BASIC
    TBASIC   ASM  Source code for TBASIC.COM
    BRENTBAS UM   BRENTBAS.EXE Users Manual
    BRENTBAS EXE  A translator from a structured BASIC to Microsoft BASIC
    TBASIC   DOC  Documentation for TBASIC.COM
{% comment %}info_end{% endcomment %}

{% comment %}samples_begin{% endcomment %}

## BASICAID.BAS

```bas
10 GOTO 280
20 GOTO 24440 ' LAST STATEMENT IN THE PROGRAM
30 '
40 'BASICAID (V2.0)  ----------- MAY 7, 1984 10 PM EST
50 '
60 '
70 '
80 'BY JAMES MORGAN
90 '   1749 AMERICANA BLVD 23-G
100 '   ORLANDO FLA. 32809        WORK PH: (305) - 826-7297
110 '
120 '*********************************************************************
130 '  A LIMITED LICENSE IS GRANTED TO ALL USERS OF THIS PROGRAM
140 ' TO MAKE COPIES OF THIS PROGRAM AND DISTRIBUTE THEM TO OTHERS
150 ' ON THE FOLLOWING CONDITIONS:
160 '        1. THE LIMITED LICENSE NOTICE , AUTHOR INFO. AND
170 '          COPYRIGHT MESSAGES ARE NOT REMOVED OR ALTERED.
180 '
190 '        2. NO FEE IS TO BE CHARGED FOR COPYING OR DISTRIBUTING
200 '          THE PROGRAM WITHOUT AN EXPRESSED WRITTEN AGREEMENT
210 '          WITH JAMES MORGAN OR HIS REPRESENTATIVES.
220 '
230 '                Copyright (c) 1983 by JAMES P MORGAN
240 '*********************************************************************
250 '
260 '
270 '
280 CLOSE
290 CLEAR
300 ON ERROR GOTO 0
310 SCREEN 0,0,0
320 WIDTH 80
330 COLOR 7,0
340 KEY OFF
350 OPTION BASE 1
360 DEFINT A-Z
370 TRUE=-1
380 FALSE=0
390 EJECT=0
400 FREE!=0
410 B$=STRING$(255,0)
420 C$=STRING$(255," ")
430 BYTE$=" "
440 P$=STRING$(255," ")
450 S$=STRING$(255," ")
460 T$=STRING$(255," ")
470 H$=STRING$(255," ")
480 SP$=STRING$(255," ")
490 SB$=STRING$(255," ")
500 CURLNUM$=STRING$(255," ")
510 S=0
520 I=0
530 J=0
540 K=0
550 L=0
560 E=0
570 I1=0
580 S1=0
590 SL=0
600 N!=0
610 N#=0
620 TWO.FIFTY.SIX!=256!
630 REMOVE.UNREFERENCED.LINENOS=0
640 SINGLE.PREC!=32768!
650 SINGLE.PREC!=SINGLE.PREC!-1
660 ZERO#=0#
670 NUM.RECS=0
680 REM1$="REM "
690 IF1$="IF "
700 DATA1$="DATA "
710 APOST$=CHR$(39)
720 QUOTE$=CHR$(34)
730 VER$="C" ' CHANGE TO "C" IF PROGRAM COMPILED
740 CR$=CHR$(13)
750 DIM CK$(124)
760 DIM CF$(37)
770 DIM DK$(30)
780 DIM DF$(6)
790 FOR I=1 TO 124
800 READ CK$(I)
810 NEXT
820 FOR I=1 TO 37
830 READ CF$(I)
840 NEXT
850 FOR I=1 TO 30
860 READ DK$(I)
870 NEXT
880 FOR I=1 TO 6
890 READ DF$(I)
900 NEXT
910 DIM EQ$(21)
920 EQ$(1)="BAD FILE NUMBER"
930 EQ$(2)="FILE NOT FOUND"
940 EQ$(3)="BAD FILE MODE"
950 EQ$(4)="FILE ALREADY OPEN"
960 EQ$(6)="DEVICE I/O ERROR"
970 EQ$(7)="FILE ALREADY EXISTS"
980 EQ$(10)="DISK FULL"
990 EQ$(11)="END OF FILE"
1000 EQ$(12)="BAD RECORD NUMBER"
1010 EQ$(13)="BAD FILE NAME"
1020 EQ$(16)="TOO MANY FILES"
1030 EQ$(19)="DISK WRITE PROTECTED"
1040 EQ$(20)="DISK NOT READY"
1050 EQ$(21)="DISK MEDIA ERROR"
1060 DIM ERRMSG$(6)
1070 ERRMSG$(1)="INVALID OR MISSING LINE NUMBER OR BINARY FILE USED AS INPUT"
1080 ERRMSG$(2)="LINE NUMBER WITH NO BASIC STATEMENT"
1090 ERRMSG$(3)="INPUT PROGRAM CONTAINS A BLANK LINE OR ONE WAS GENERATED"
1100 ERRMSG$(4)="LITERAL STRING BOUND IN QUOTES MISSING TERMINATING QUOTE"
1110 ERRMSG$(5)="CURRENT LINE NUMBER NOT GREATER THAN PREVIOUS LINE NUMBER"
1120 ERRMSG$(6)="LINE NUMBER TABLE IS FULL, TOO MANY LOGIC BRANCH REFERENCES"
1130 FREECNT=0
1140 BEEPCNT=3
1150 BEEPLOOP=600
1160 LPRNT=0
1170 GOSUB 14310 'TOGGLE CAPSLOCK ON
1180 GOSUB 11700 'WHAT KIND OF VIDEO ADAPTER
1190 GOSUB 11850 'display Soft-SHARE logo
1200 GOSUB 12120 'REQUEST RUNTIME OPTIONS
1210 START$=""
1220 FINISH$=""
1230 S=1
1240 ROWLINES=10
1250 PAGESIZE=50
1260 FREELMT=10
1270 LINECNT=0
1280 PRVLNUM=-32768!
1290 CURLINE!=0
1300 '
1310 IF RUNTYPE<3 GOTO 1470
1320 IF RUNTYPE>4 GOTO 1470
1330 READ RESCNT
1340 DIM RESWRD$(158) ' RESWRD$(153)    FIXED IF COMPILED
1350 DIM WORDFLAG(158) ' WORDFLAG(153)   FIXED IF COMPILED
1360 FOR I=1 TO RESCNT
1370 READ RESWRD$(I),WORDFLAG(I)
1380 NEXT
1390 '
1400 DNMCNT=500
1410 IF RUNTYPE=4 THEN DNMCNT=RESCNT
1420 DIM DATANAME$(500) ' DATANAME$(100) FIXED IF COMPILED
1430 FOR X=1 TO DNMCNT
1440 DATANAME$=""
1450 NEXT
1460 '
1470 IF RUNTYPE<2 GOTO 1630
1480 NUMLINES=1
1490 DIMLINE=500
1500 IF RUNTYPE=4 THEN DIMLINE=RESCNT
1510 YCNT=4
1520 IF ACTUAL.RUNTYPE=5 THEN YCNT=4
1530 DIM REF.LINENOS(1,300)
1540 FOR X=1 TO 300
1550 REF.LINENOS(1,X)=-32768!
1560 NEXT
1570 DIM LINENOS(500,4) ' LINENOS(100,50) FIXED IF COMPILED
1580 FOR X=1 TO DIMLINE
1590 LINENOS(X,1)=-32768!
1600 LINENOS(X,2)=0
1610 NEXT
1620 '
1630 CLS
1640 ON ERROR GOTO 0
1650 LOCATE 2,1,1
1660 PRINT "ENTER THE BASIC PROGRAM NAME TO BE PROCESSED"
1670 PRINT
1680 GOSUB 12610 'FLUSH KEYBOARD BUFFERS
1690 INPUT "PROGRAM NAME : ",BASPGM$
1700 IF LEN(BASPGM$)<1 GOTO 1630
1710 IF LEN(BASPGM$)>8 GOTO 1630
1720 LOCATE 5,1,0
1730 FOR I=1 TO 24 - CSRLIN
1740 PRINT STRING$(79," ")
1750 NEXT
1760 GOSUB 1940 'CLEAR 24-25
1770 LOCATE 6,1,1
1780 BEEP
1790 PRINT "WHAT DRIVE IS THE FILE ON, (PRESS ENTER FOR DEFAULT DRIVE)"
1800 PRINT
1810 PRINT "DRIVE : ";
1820 GOSUB 12610 'FLUSH BUFFERS
1830 DRIVE$=INKEY$
1840 IF DRIVE$="" GOTO 1830
1850 IF DRIVE$=CR$ THEN DRIVE$="":GOTO 2010
1860 IF LEN(DRIVE$)>1 GOTO 1720
1870 IF DRIVE$=CHR$(27) GOTO 17570
1880 IF DRIVE$<"A" GOTO 1720
1890 IF DRIVE$>"Z" GOTO 1720
1900 PRINT DRIVE$;
1910 DRIVE$=DRIVE$+":"
1920 GOTO 2010
1930 '
1940 LOCATE 24,1
1950 PRINT STRING$(79," ");
1960 LOCATE 25,1,0
1970 PRINT STRING$(79," ");
1980 LOCATE,,1
1990 RETURN
2000 '
2010 DSN$=DRIVE$+BASPGM$+".BAS"
2020 ON ERROR GOTO 5690
2030 PHASE=1
2040 PRINT
2050 FILES DSN$
2060 GOSUB 20370 'CHECK TYPE STORED PGM
2070 IF READY.TO.RETURN=0 GOTO 17570
2080 IF TYPE.STORED.PGM>252 GOTO 2110
2090 ON ERROR GOTO 0
2100 OPEN DSN$ FOR INPUT AS 1
2110 IF (RUNTYPE=1) OR (ACTUAL.RUNTYPE=5) GOTO 2120 ELSE GOTO 2170
2120 OUTFILE$="TEMPFILE.BAS"
2130 IF RUNTYPE=1 THEN REASON$="EXPANDING PROGRAM" ELSE REASON$="COMPRESSING PROGRAM"
2140 GOSUB 13300 'OPEN OUTPUT FILE
2150 GOTO 2210
2160 '
2170 IF ACTUAL.RUNTYPE>4 GOTO 2210
2180 REASON$="CREATING LINE NUMBER FILE"
2190 GOSUB 13790 'OPEN LINE NO FILE
2200 '
2210 START$=TIME$
2220 LOCATE 25,1,0
2230 PRINT "PROCESSING LINE NUMBER =             ";
2240 IF TYPE.STORED.PGM>252 GOTO 2270
2250 IF READY.TO.RETURN=255 GOTO 6140
2260 IF EOF(1) GOTO 6140
2270 GOSUB 2410 ' READ INPUT BASIC PROGRAM
2280 IF LEN.B=0 GOTO 6140
2290 L=LEN.B
2300 GOSUB 5290 ' FIND END OF THE BASIC INPUT LINE
2310 E=BEND
2320 GOSUB 3630 ' ISOLATE LINE NUMBER AND FIND FIRST STATEMENT
2330 IF BEGIN=0 GOTO 2250
2340 'PRINT HEADINGS FOR LINE NUMBER CROSS REFERENCE
2350 GOSUB 11640 ' PRINT LINE NUMBER CURRENTLY PROCESSING
2360 GOSUB 2780 ' SEPARATE LINE INTO ONE OR MORE STATEMENTS
2370 GOTO 2250
2380 '
2390 ' READ THE BASIC PROGRAM TO BE EXPANDED/COMPRESSED/XREFERENCED
2400 '
2410 IF TYPE.STORED.PGM<>255 GOTO 2460
2420 GOSUB 17750 'BUILD ASCII STRING FORM TOKENIZED BASIC PROGAM
2430 IF READY.TO.RETURN GOTO 2510
2440 IF READY.TO.RETURN<>255 GOTO 17570
2450 GOTO 2510
2460 ON ERROR GOTO 2550
2470 LINE INPUT#1,TEMP.B$
2480 ON ERROR GOTO 0
2490 MID$(B$,1)=TEMP.B$
2500 LEN.B=LEN(TEMP.B$)
2510 RETURN
2520 '
2530 ' ERROR HANDLING ROUTINE ON THE INPUT (BASIC PROGRAM)
2540 '
2550 ROW=CSRLIN
2560 COLUMN=POS(0)
2570 GOSUB 5840 'DETERMINE TYPE OF FILE ERROR
2580 RESUME 2590
2590 ON ERROR GOTO 0
2600 GOSUB 1940 'CLEAR 24-25
2610 LOCATE 25,1,1
2620 COLOR 15
2630 PRINT "READ ON BASIC PROGRAM FAILED. ";M$;
2640 M$=" "
2650 LOCATE 24,1
2660 PRINT "CORRECT PROBLEM AND PRESS ANY KEY TO CONTINUE";
2670 GOSUB 12610 'FLUSH BUFFERS
2680 KEYIN$=INKEY$
2690 IF LEN(KEYIN$)=0 GOTO 2680
2700 IF KEYIN$=CHR$(27) GOTO 17570
2710 COLOR 7
2720 GOSUB 1940 'CLEAR 24-25
2730 LOCATE ROW,COLUMN,0
2740 GOTO 2410
2750 '
2760 '  SEPARATE BASIC STATEMENTS INTO ONE OR MORE STATEMENTS
2770 '
2780 S=BEGIN
2790 FOR I=S TO E
2800 MID$(BYTE$,1,1)=MID$(B$,I,1)
2810 IF BYTE$=QUOTE$ GOTO 5550 ' START OF NON-NUMERIC CHAR. STRING FOUND
2820 IF BYTE$="'" GOTO 3430 ' TERMINATING REMARK ON THE LINE
2830 IF BYTE$<>":" GOTO 3290
2840 '
2850 ' A ":" WAS FOUND INDICATING THAT THERE ARE MULTIPLE STATEMENTS ON THIS LINE
2860 '
2870 IF I-S<1 GOTO 3070 ' THROW AWAY ":" THAT ARE NEXT TO EACH OTHER
2880 MID$(P$,1)=MID$(B$,S,I-S)
2890 LEN.P=I-S
2900 IF RUNTYPE=1 GOTO 2930
2910 GOSUB 7260 'ISOLATE DATA NAMES AND LINE NUMBERS
2920 IF (RUNTYPE=1) OR (ACTUAL.RUNTYPE=5) GOTO 2930 ELSE GOTO 2980
2930 GOSUB 4850 'ADD LINE NO TO STATEMENT
2940 IF ACTUAL.RUNTYPE=5 GOTO 2960
2950 IF LPRNT THEN LPRINT MID$(P$,1,LEN.P)
2960 GOSUB 4920 'WRITE A NEW BASIC LINE
2970 LINENO=LINENO + 1
2980 GOSUB 11640 'PRINT CURRENT LINE NO
2990 TEMP.CURLNUM$=STR$(LINENO + SINGLE.PREC!)
3000 ITSLEN=LEN(TEMP.CURLNUM$)-1
3010 MID$(CURLNUM$,1)=RIGHT$(TEMP.CURLNUM$,ITSLEN)
3020 LEN.CURLNUM=ITSLEN
3030 PRVLNUM=LINENO
3040 '
3050 ' THE ":" WAS FOUND, NOW SCAN FOR FIRST NON.BLANK CHAR.
3060 '
3070 S=I+1
3080 IF E-S<1 GOTO 3410 'WE ARE THRU WITH THIS LINE
3090 MID$(BYTE$,1,1)=MID$(B$,S,1)
3100 IF BYTE$<=" " THEN I=S:GOTO 3070
3110 '
3120 ' CHECK IF "REM" OR "IF" STATEMENT IMBEDDED ON THIS LINE
3130 '
3140 IF (BYTE$<>"I") AND (BYTE$<>"R") GOTO 2790
3150 IF BYTE$<>"I" GOTO 3230
3160 MID$(C$,1)=MID$(B$,S,3)
3170 LEN.C=LEN.B-S+1
3180 IF LEN.C>3 THEN LEN.C=3
3190 GOSUB 3460 'CHECK IF "IF"
3200 IF MID$(C$,1,LEN.C)=IF1$ GOTO 3430
3210 GOTO 2790
3220 '
3230 MID$(C$,1)=MID$(B$,S,4)
3240 LEN.C=LEN.B-S+1
3250 IF LEN.C>4 THEN LEN.C=4
3260 GOSUB 4970 'CHECK IF "REM"
3270 IF MID$(C$,1,LEN.C)=REM1$ GOTO 3430
3280 GOTO 2790
3290 NEXT I
3300 '
3310 MID$(P$,1)=MID$(B$,S,I-S)
3320 LEN.P=I-S
3330 IF RUNTYPE=1 GOTO 3360
3340 GOSUB 7260 'ISOLATE DATA NAMES AND LINE NUMBERS
3350 IF (RUNTYPE=1) OR (ACTUAL.RUNTYPE=5) GOTO 3360 ELSE GOTO 3400
3360 GOSUB 4850 'ADD LINE NO TO STATEMENT
3370 IF ACTUAL.RUNTYPE=5 GOTO 3390
3380 IF LPRNT THEN LPRINT MID$(P$,1,LEN.P)
3390 GOSUB 4920 ' WRITE THE NEW BASIC LINE
3400 GOSUB 11640 'PRINT CURRENT LINE NO.
3410 RETURN
3420 '
3430 I=E+1
3440 GOTO 3310
3450 '
3460 IF LEN.C<2 THEN RETURN
3470 IF MID$(C$,1,2)<>"IF" THEN RETURN
3480 IF LEN.C<3 THEN RETURN
3490 IF MID$(C$,3,1)=" " THEN RETURN
3500 IF MID$(C$,3,1)="." THEN RETURN
3510 IF ASC(MID$(C$,3,1))<48 GOTO 3560
3520 IF ASC(MID$(C$,3,1))>90 GOTO 3560
3530 IF (ASC(MID$(C$,3,1))>57) AND (ASC(MID$(C$,3,1))<65) GOTO 3560
3540 RETURN
3550 '
3560 MID$(C$,1)="IF "
3570 LEN.C=3
3580 RETURN
3590 '
3600 '  ISOLATE LINE NUMBER AND FIND START OF BASIC STATEMENT(S)
3610 '
3620 ' FIND THE FIRST NON-BLANK CHAR.
3630 BEGIN=0
3640 MID$(CURLNUM$,1)=STRING$(6," ")
3650 FOR I=1 TO E
3660 MID$(BYTE$,1,1)=MID$(B$,I,1)
3670 IF BYTE$>" " GOTO 3690
3680 NEXT I
3690 S=I
3700 MID$(P$,1)=STRING$(255," ")
3710 LEN.P=0
3720 '
3730 ' SCAN UNTIL FIRST NON-NUMERIC CHAR (BUILDING LINE NUMBER)
3740 '
3750 FOR I=S TO E
3760 MID$(BYTE$,1,1)=MID$(B$,I,1)
3770 IF BYTE$<"0" GOTO 3830
3780 IF BYTE$>"9" GOTO 3830
3790 LEN.P=LEN.P+1
3800 MID$(P$,LEN.P,1)=BYTE$
3810 NEXT I
3820 ' DO WE HAVE A INVALID LINE NUMBER
3830 IF I=E THEN ERRNO=1:GOTO 5470
3840 IF LEN.P>5 THEN ERRNO=1:GOTO 5470
3850 IF LEN.P>0 GOTO 3950
3860 '
3870 ' UNNUBMBERED BASIC STATEMENT, SUPPLY A LINE NO.
3880 '
3890 CURLINE!=PRVLNUM+32767+ZERO#+1
3900 IF CURLINE!=0 THEN CURLINE!=1
3910 TEMP.CURLNUM$=STR$(CURLINE!)
3920 ITSLEN=LEN(TEMP.CURLNUM$)-1
3930 LEN.P=ITSLEN
3940 MID$(P$,1)=RIGHT$(TEMP.CURLNUM$,ITSLEN)
3950 MID$(CURLNUM$,1)=STRING$(6," ")
3960 MID$(CURLNUM$,1)=MID$(P$,1,LEN.P)
3970 LEN.CURLNUM=LEN.P
3980 CURLINE!=VAL(MID$(CURLNUM$,1,LEN.CURLNUM))
3990 LINENO=CURLINE! - 32767
4000 IF (RUNTYPE=1) OR (ACTUAL.RUNTYPE=5) THEN GOTO 4010 ELSE GOTO 4020
4010 IF LINENO<=PRVLNUM THEN ERRNO=5:GOTO 5470
4020 PRVLNUM=LINENO
4030 '
4040 ' SCAN UNTIL WE FIND THE FIRST NON-BLANK CHAR (FIND FIRST BASIC STATEMENT)
4050 '
4060 S=I
4070 FOR I=S TO E
4080 MID$(BYTE$,1,1)=MID$(B$,I,1)
4090 IF BYTE$>" " GOTO 4120
4100 NEXT I
4110 IF I=E THEN ERRNO=2:GOTO 5470
4120 BEGIN=I
4130 IF BYTE$=":" GOTO 4680 ' REMOVE ALL LEADING ":"
4140 IF BYTE$="'" GOTO 4710 ' THIS MUST BE A COMMENT STATEMENT
4150 '
4160 ' CHECK IF THE LINE BEGINS AS A "REM" OR "DATA" OR "IF" STATEMENT
4170 '
4180 IF (BYTE$<>"R") AND (BYTE$<>"D") AND (BYTE$<>"I") THEN RETURN
4190 IF BYTE$<>"R" GOTO 4270
4200 MID$(C$,1)=MID$(B$,I,4)
4210 LEN.C=LEN.B-I+1
4220 IF LEN.C>4 THEN LEN.C=4
4230 GOSUB 4970 'CHECK IF "REM"
4240 IF MID$(C$,1,LEN.C)=REM1$ GOTO 4710
4250 RETURN
4260 '
4270 IF BYTE$<>"I" GOTO 4350
4280 MID$(C$,1)=MID$(B$,I,3)
4290 LEN.C=LEN.B-I+1
4300 IF LEN.C>3 THEN LEN.C=3
4310 GOSUB 3460 'CHECK IF "IF"
4320 IF MID$(C$,1,LEN.C)=IF1$ GOTO 4710
4330 RETURN
4340 '
4350 MID$(C$,1)=MID$(B$,I,5)
4360 LEN.C=LEN.B-I+1
4370 IF LEN.C>5 THEN LEN.C=5
4380 GOSUB 5120 'CHECK IF "DATA"
4390 IF MID$(C$,1,LEN.C)<>DATA1$ THEN RETURN
4400 DATA.INX=I
4410 GOSUB 4450 'CHECK IF ONLY "DATA" ON THIS STATEMENT
4420 IF DATA.SINGLE GOTO 4710
4430 RETURN
4440 '
4450 DATA.SINGLE=-1
4460 FOR DATA.INX=DATA.INX TO E
4470 MID$(BYTE$,1,1)=MID$(B$,DATA.INX,1)
4480 IF BYTE$=QUOTE$ THEN GOSUB 4620:GOTO 4460
4490 IF BYTE$=":" GOTO 4530
4500 NEXT DATA.INX
4510 RETURN
4520 '
4530 DATA.INX=DATA.INX+1
4540 IF DATA.INX>E THEN RETURN
4550 MID$(BYTE$,1,1)=MID$(B$,DATA.INX,1)
4560 IF BYTE$=":" THEN MID$(B$,DATA.INX,1)=" ":GOTO 4530
4570 IF BYTE$="'" THEN RETURN
4580 IF BYTE$>" " THEN DATA.SINGLE=0:RETURN
4590 MID$(B$,DATA.INX,1)=" "
4600 GOTO 4530
4610 '
4620 DATA.INX=DATA.INX+1
4630 IF DATA.INX>E THEN RETURN
4640 MID$(BYTE$,1,1)=MID$(B$,DATA.INX,1)
4650 IF BYTE$=QUOTE$ THEN DATA.INX=DATA.INX+1:RETURN
4660 GOTO 4620
4670 '
4680 MID$(B$,I,1)=" "
4690 GOTO 4060
4700 '
4710 BEGIN=0
4720 S=I
4730 MID$(P$,1)=MID$(B$,S)
4740 LEN.P=LEN.B-S+1
4750 IF RUNTYPE=1 GOTO 4780
4760 GOSUB 7260 'ISOLATE DATA NAMES AND LINE NUMBERS
4770 IF (RUNTYPE=1) OR (ACTUAL.RUNTYPE=5) THEN GOTO 4780 ELSE GOTO 4820
4780 GOSUB 4850 'ADD LINE NO TO STATEMENT
4790 IF ACTUAL.RUNTYPE=5 GOTO 4810
4800 IF LPRNT THEN LPRINT MID$(P$,1,LEN.P)
4810 GOSUB 4920 ' CREATE (WRITE) THE NEW BASIC LINE
4820 GOSUB 11640 'PRINT CURRENT LINE NO
4830 RETURN
4840 '
4850 LEN.P=LEN.P+LEN.CURLNUM+1
4860 MID$(P$,LEN.CURLNUM+2)=MID$(P$,1)
4870 MID$(P$,1,LEN.CURLNUM+1)=MID$(CURLNUM$,1,LEN.CURLNUM+1)
4880 RETURN
4890 '
4900 ' CREATE (WRITE) THE NEW BASIC LINE(S)
4910 '
4920 ON ERROR GOTO 5910
4930 PRINT#2,MID$(P$,1,LEN.P)
4940 ON ERROR GOTO 0
4950 RETURN
4960 '
4970 IF LEN.C<3 THEN RETURN
4980 GOSUB 5390 'CONVERT TO UPPER CASE
4990 IF MID$(C$,1,3)<>"REM" THEN RETURN
5000 IF LEN.C=3 GOTO 5080
5010 IF MID$(C$,4,1)=" " THEN RETURN
5020 IF MID$(C$,4,1)="." THEN RETURN
5030 IF ASC(MID$(C$,4,1))<48 GOTO 5080
5040 IF ASC(MID$(C$,4,1))>90 GOTO 5080
5050 IF (ASC(MID$(C$,4,1))>57) AND (ASC(MID$(C$,4,1))<65) GOTO 5080
5060 RETURN
5070 '
5080 MID$(C$,1)="REM "
5090 LEN.C=4
5100 RETURN
5110 '
5120 IF LEN.C<4 THEN RETURN
5130 GOSUB 5390 'CONVERT TO UPPER CASE
5140 IF MID$(C$,1,4)<>"DATA" THEN RETURN
5150 IF LEN.C=4 GOTO 5230
5160 IF MID$(C$,5,1)=" " THEN RETURN
5170 IF MID$(C$,5,1)="." THEN RETURN
5180 IF ASC(MID$(C$,5,1))<48 GOTO 5230
5190 IF ASC(MID$(C$,5,1))>90 GOTO 5230
5200 IF (ASC(MID$(C$,5,1))>57) AND (ASC(MID$(C$,5,1))<65) GOTO 5230
5210 RETURN
5220 '
5230 MID$(C$,1)="DATA "
5240 LEN.C=5
5250 RETURN
5260 '
5270 '  FIND TRUE END OF A STATEMENT LINE
5280 '
5290 GOSUB 16990 'CHECK FOR DOUBLE QUOTES, ALSO COMPRESS INPUT LINE
5300 FOR I=L TO 1 STEP -1 ' START AT END OF THE LINE
5310 MID$(BYTE$,1,1)=MID$(B$,I,1)
5320 IF BYTE$<>" " GOTO 5340
5330 NEXT I
5340 IF I=1 THEN ERRNO=3:GOTO 5470
5350 L=I
5360 BEND=I
5370 RETURN
5380 '
5390 IF TYPE.STORED.PGM >252 THEN RETURN
5400 FOR J=1 TO LEN.C
5410 MID$(C$,J,1)=CHR$(ASC(MID$(C$,J,1)) AND 95)
5420 NEXT
5430 RETURN
5440 '
5450 ' ALMOST ALL ERRORS DETECTED WHILE SCANNING PROGRAM SHOULD COME TO HERE
5460 '
5470 PRINT
5480 PRINT "error - check logic or data"
5490 PRINT
5500 PRINT ERRMSG$(ERRNO)
5510 GOTO 17570
5520 '
5530 '  SCAN OVER STRING LITERALS BOUND IN QUOTES
5540 '
5550 K=I+1
5560 FOR J=K TO E
5570 MID$(BYTE$,1,1)=MID$(B$,J,1)
5580 IF BYTE$=QUOTE$ GOTO 5660
5590 NEXT J
5600 '
5610 PRINT
5620 PRINT "PROGRAM TRAP REACHED"
5630 STOP
5640 END
5650 '
5660 I=J
5670 GOTO 3290
5680 '
5690 PRINT
5700 PRINT "** ERROR ";ERR;" ACCESSING ";DSN$
5710 IF ERR=53 THEN PRINT DSN$;" NOT ON DISKETTE"
5720 RESUME 5730
5730 ON ERROR GOTO 0
5740 PRINT
5750 PRINT "PRESS ANY KEY TO CONTINUE"
5760 GOSUB 12610 'FLUSH BUFFERS
5770 KEYIN$=INKEY$
5780 IF KEYIN$="" GOTO 5770
5790 IF KEYIN$=CHR$(27) GOTO 17570
5800 GOTO 1630
5810 '
5820 ' WHAT TYPE OF BASIC ERROR WAS FOUND, MOSTLY CONCERNED WITH FILE ERRORS
5830 '
5840 IF ERR<52 THEN M$="":GOTO 5860
5850 M$=EQ$(ERR-51)
5860 IF M$="" THEN M$="BASIC ERROR "+STR$(ERR)
5870 RETURN
5880 '
5890 ' ERROR HANDLING ROUTINES FOR THE OUTPUT BASIC PROGRAM
5900 '
5910 ROW=CSRLIN
5920 COLUMN=POS(0)
5930 GOSUB 5840 'GET TYPE ERR
5940 RESUME 5950
5950 ON ERROR GOTO 0
5960 GOSUB 1940 'CLEAR 24-25
5970 LOCATE 25,1,1
5980 COLOR 15
5990 PRINT "EXPANDED PROGRAM WRITE FAILED. ";M$;
6000 M$=" "
6010 LOCATE 24,1
6020 PRINT "CORRECT PROBLEM AND PRESS ANY KEY TO CONTINUE";
6030 GOSUB 12610 'FLUSH BUFFERS
6040 KEYIN$=INKEY$
6050 IF LEN(KEYIN$)=0 GOTO 6040
6060 IF KEYIN$=CHR$(27) GOTO 17570
6070 COLOR 7
6080 GOSUB 1940 'CLEAR 24-25
6090 LOCATE ROW,COLUMN,0
6100 GOTO 4920
6110 '
6120 '  END-OF-FILE ROUTINES
6130 '
6140 CLS
6150 IF RUNTYPE<>2 GOTO 6300
6160 GOSUB 10010 ' SORT THE LINE NUMBER REFERENCES
6170 IF ACTUAL.RUNTYPE=5 GOTO 6370
6180 GOSUB 10610 ' PRINT HEADINGS FOR LINE NUMBER REFERENCES
6190 FOR X=1 TO NUMLINES
6200 IF LINENOS(X,1)=-32768! GOTO 6220
6210 GOSUB 6550 ' PRINT LINE NUMBER REFERENCES
6220 NEXT
6230 FOR I=1 TO 2
6240 LPRINT
6250 NEXT
6260 LPRINT "NOTE: LINE NUMBER APPLIES TO ANY line-number REFERENCED BY A :"
6270 LPRINT
6280 LPRINT "     GOTO, GOSUB, RESUME, RESTORE, RETURN, RUN, THEN, ELSE OR ERL STATEMENT"
6290 LPRINT
6300 IF RUNTYPE<3 GOTO 6370
6310 GOSUB 11060 ' SORT THE DATA NAME TABLE
6320 GOSUB 11440 ' PRINT THE LISTING HEADINGS
6330 FOR X=1 TO NUMLINES
6340 IF DATANAME$(X)="" GOTO 6360
6350 GOSUB 6550 ' PRINT THE LINE NUMBER REFERENCES
6360 NEXT
6370 PRINT
6380 FINISH$=TIME$
6390 PRINT "PROGRAM START  TIME = ";START$
6400 PRINT "PROGRAM FINISH TIME = ";FINISH$
6410 PRINT DSN$;" SUCCESSFULLY PROCESSED..."
6420 PRINT
6430 IF ACTUAL.RUNTYPE=5 GOTO 14410
6440 GOSUB 6470 'RESET PRINTER
6450 GOTO 17570
6460 '
6470 IF EJECT=0 GOTO 6500
6480 LPRINT CHR$(18) + CHR$(12)
6490 WIDTH "LPT1:",80
6500 RETURN
6510 '
6520 '
6530 '  PRINT LINE NUMBER REFERENCES
6540 '
6550 TOCNT=0
6560 REF.LINENOS(1,1)=LINENOS(X,1)
6570 REF.LINENOS(1,2)=0
6580 REF.LINENOS(1,3)=LINENOS(X,3)
6590 GOSUB 6900
6600 TOCNT=REF.LINENOS(1,2)
6610 TABPOS=3
6620 IF RUNTYPE=2 GOTO 6660
6630 IF LINECNT>PAGESIZE THEN GOSUB 11440
6640 GOTO 6670
6650 '
6660 IF LINECNT>PAGESIZE THEN GOSUB 10610
6670 LPRINT
6680 IF RUNTYPE=2 GOTO 6730
6690 LPRINT DATANAME$(X)
6700 LINECNT=LINECNT + 1
6710 GOTO 6750
6720 '
6730 CURLINE!=REF.LINENOS(1,1) + SINGLE.PREC!
6740 LPRINT CURLINE!;
6750 TABPOS=20
6760 L=1
6770 FOR I=1 TO ROWLINES
6780 CURLINE!=REF.LINENOS(1,L+3) + SINGLE.PREC!
6790 LPRINT TAB(TABPOS) CURLINE!;
6800 L=L + 1
6810 IF L>TOCNT GOTO 6840
6820 TABPOS=TABPOS + 8
6830 NEXT I
6840 TABPOS=20
6850 LPRINT
6860 LINECNT=LINECNT + 2
6870 IF L<=TOCNT GOTO 6770
6880 RETURN
6890 '
6900 SEARCH.LINENO=LINENOS(X,1)
6910 FOR SRCH.INX1=1 TO NUM.RECS
6920 ON ERROR GOTO 10370
6930 IO.ADDR=6
6940 GET #3,SRCH.INX1
6950 ON ERROR GOTO 0
6960 X1=CVI(DSK.LINETO$)
6970 X2=CVI(DSK.LINENO$)
6980 IF X1<>SEARCH.LINENO GOTO 7030
6990 IF TOCNT=0 GOTO 7010
7000 IF X2=REF.LINENOS(1,TOCNT+3) GOTO 7030
7010 TOCNT=TOCNT+1
7020 REF.LINENOS(1,TOCNT+3)=X2
7030 NEXT
7040 REF.LINENOS(1,2)=TOCNT
7050 GOSUB 7080
7060 RETURN
7070 '
7080 IF TOCNT=1 THEN RETURN
7090 LAST=TOCNT
7100 GAP=LAST\2
7110 WHILE GAP>0
7120 FOR I=GAP+1 TO LAST
7130 J=I-GAP
7140 WHILE J>0
7150 IF REF.LINENOS(1,J+3)<=REF.LINENOS(1,J+GAP+3) THEN J=0:GOTO 7180
7160 SWAP REF.LINENOS(1,J+3),REF.LINENOS(1,J+GAP+3)
7170 J=J-GAP
7180 WEND
7190 NEXT
7200 GAP=GAP\2
7210 WEND
7220 RETURN
7230 '
7240 ' ISOLATE DATANAMES/RESERVED WORDS AND LINE NUMBERS
7250 '
7260 MID$(SP$,1)=MID$(P$,1,LEN.P)
7270 LEN.SP=LEN.P
7280 SL=LEN.SP
7290 IF MID$(SP$,1,1)="'" GOTO 7510
7300 GOSUB 7610 'CHECK IF "REM"
7310 IF MID$(SP$,1,4)=REM1$ GOTO 7510
7320 GOSUB 7760 'CHECK IF "IF"
7330 IF MID$(SP$,1,5)=DATA1$ GOTO 7560
7340 GOSUB 7930 'REMOVE STRING LITERALS
7350 FOR I1=1 TO SL
7360 V=ASC(MID$(SP$,I1,1))
7370 IF V=46 GOTO 7460 ' "."
7380 IF V=38 GOTO 7460 ' "&"
7390 IF V<48 GOTO 7450 ' "0"
7400 IF V>90 GOTO 7450 ' "Z"
7410 IF V>64 GOTO 7460 ' "@"
7420 IF V>57 GOTO 7450 ' "9"
7430 GOTO 7460
7440 '
7450 MID$(SP$,I1,1)=" "
7460 NEXT I1
7470 GOSUB 8180 'FIND END OF LINE
7480 GOSUB 8270 'PARSE OUT RESERVED WORD/LINE NOS/DATA NAMES
7490 RETURN
7500 '
7510 MID$(SP$,1,4)="REM"
7520 LEN.SP=3
7530 SL=LEN.SP
7540 GOTO 7480
7550 '
7560 MID$(SP$,1,4)="DATA"
7570 LEN.SP=4
7580 SL=LEN.SP
7590 GOTO 7480
7600 '
7610 IF LEN.SP<3 THEN RETURN
7620 IF MID$(SP$,1,3)<>"REM" THEN RETURN
7630 IF LEN.SP=3 GOTO 7710
7640 IF MID$(SP$,4,1)=" " THEN RETURN
7650 IF MID$(SP$,4,1)="." THEN RETURN
7660 IF ASC(MID$(SP$,4,1))<48 GOTO 7710
7670 IF ASC(MID$(SP$,4,1))>90 GOTO 7710
7680 IF (ASC(MID$(SP$,4,1))>57) AND (ASC(MID$(SP$,4,1))<65) GOTO 7710
7690 RETURN
7700 '
7710 MID$(SP$,1)="REM "
7720 LEN.SP=4
7730 SL=LEN.SP
7740 RETURN
7750 '
7760 IF LEN.SP<4 THEN RETURN
7770 IF MID$(SP$,1,4)<>"DATA" THEN RETURN
7780 IF LEN.SP=4 GOTO 7860
7790 IF MID$(SP$,5,1)=" " THEN RETURN
7800 IF MID$(SP$,5,1)="." THEN RETURN
7810 IF ASC(MID$(SP$,5,1))<48 GOTO 7860
7820 IF ASC(MID$(SP$,5,1))>90 GOTO 7860
7830 IF (ASC(MID$(SP$,5,1))>57) AND (ASC(MID$(SP$,5,1))<65) GOTO 7860
7840 RETURN
7850 '
7860 MID$(SP$,1)="DATA "
7870 LEN.SP=5
7880 SL=LEN.SP
7890 RETURN
7900 '
7910 '  REMOVE STRING LITERALS BOUND IN QUOTES AND COMMENTS
7920 '
7930 S1=1
7940 FOR I1=S1 TO SL
7950 MID$(BYTE$,1,1)=MID$(SP$,I1,1)
7960 IF BYTE$=QUOTE$ GOTO 8010
7970 IF BYTE$="'" GOTO 8130
7980 NEXT I1
7990 GOTO 8180
8000 '
8010 MID$(SP$,I1,1)=" "
8020 FOR I1=I1 TO SL
8030 MID$(BYTE$,1,1)=MID$(SP$,I1,1)
8040 IF BYTE$=QUOTE$ GOTO 8090
8050 MID$(SP$,I1,1)=" "
8060 NEXT I1
8070 GOTO 8180
8080 '
8090 MID$(SP$,I1,1)=" "
8100 S1=I1
8110 GOTO 7940
8120 '
8130 MID$(SP$,I1,1)=" "
8140 MID$(SP$,1)=MID$(SP$,1,I1)
8150 LEN.SP=I1
8160 SL=LEN.SP
8170 '
8180 FOR I1=SL TO 1 STEP -1
8190 MID$(BYTE$,1,1)=MID$(SP$,I1,1)
8200 IF BYTE$<>" " GOTO 8220
8210 NEXT I1
8220 MID$(SP$,1)=MID$(SP$,1,I1)
8230 LEN.SP=I1
8240 SL=LEN.SP
8250 RETURN
8260 '
8270 S1=1
8280 GOSUB 8770 'GET A WORD
8290 IF LEN.C=0 GOTO 8370
8300 IF C$<"A" GOTO 8280
8310 IF RUNTYPE=2 GOTO 8610
8320 GOSUB 8410 'BINARY SEARCH OF RESERVED WORD TABLE
8330 IF FOUND=1 GOTO 8610
8340 IF RUNTYPE<>3 GOTO 8280
8350 GOSUB 9190 'ADD DATANAMES/LINENOS TO THEIR TABLES
8360 GOTO 8280
8370 RETURN
8380 '
8390 '  BINARY SEARCH OF RESERVED WORD TABLE
8400 '
8410 FOUND=0
8420 LOW!=1
8430 HIGH!=RESCNT
8440 HALF=FIX((HIGH!/2) + .5)
8450 NOW=HALF
8460 IF MID$(C$,1,LEN.C)=RESWRD$(NOW) GOTO 8580
8470 IF MID$(C$,1,LEN.C)<RESWRD$(NOW) GOTO 8550
8480 LOW!=NOW + 1
8490 IF LOW!>HIGH! GOTO 8590
8500 IF HIGH!<LOW! GOTO 8590
8510 NUW=FIX((HIGH!-LOW!)/2! + .5)
8520 NOW=NUW+LOW!
8530 GOTO 8460
8540 '
8550 HIGH!=NOW - 1
8560 GOTO 8490
8570 '
8580 FOUND=1
8590 RETURN
8600 '
8610 IF MID$(C$,1,LEN.C)="GOTO" GOTO 9050
8620 IF MID$(C$,1,LEN.C)="GOSUB" GOTO 9050
8630 IF MID$(C$,1,LEN.C)="RESUME" GOTO 8930
8640 IF MID$(C$,1,LEN.C)="THEN" GOTO 8930
8650 IF MID$(C$,1,LEN.C)="ELSE" GOTO 8930
8660 IF MID$(C$,1,LEN.C)="ERL" GOTO 8930
8670 IF MID$(C$,1,LEN.C)="RESTORE" GOTO 8930
8680 IF MID$(C$,1,LEN.C)="RETURN" GOTO 8930
8690 IF MID$(C$,1,LEN.C)="RUN" GOTO 8930
8700 IF RUNTYPE<>4 GOTO 8280
8710 IF WORDFLAG(NOW)=0 GOTO 8280
8720 GOSUB 9190 'ADD TO TABLE
8730 GOTO 8280
8740 '
8750 '  GET A WORD
8760 '
8770 MID$(C$,1)=STRING$(255," ")
8780 LEN.C=0
8790 FOR I1=S1 TO SL
8800 MID$(BYTE$,1,1)=MID$(SP$,I1,1)
8810 IF BYTE$<>" " GOTO 8830
8820 NEXT I1
8830 MID$(C$,1)=STRING$(255," ")
8840 LEN.C=0
8850 FOR I1=I1 TO SL
8860 IF MID$(SP$,I1,1)=" " GOTO 8900
8870 LEN.C=LEN.C+1
8880 MID$(C$,LEN.C,1)=MID$(SP$,I1,1)
8890 NEXT I1
8900 S1=I1
8910 RETURN
8920 '
8930 IF RUNTYPE<>4 GOTO 8960
8940 IF WORDFLAG(NOW)=0 GOTO 8960
8950 GOSUB 9190 'ADD TO TABLE
8960 S1=I1
8970 IF RUNTYPE<>2 GOTO 8280
8980 GOSUB 8770 'GET A WORD
8990 IF LEN.C=0 GOTO 9030
9000 IF ASC(C$)>64 GOTO 8310
9010 GOSUB 9190 'ADD TO TABLE
9020 GOTO 8280
9030 RETURN
9040 '
9050 IF RUNTYPE<>4 GOTO 9080
9060 IF WORDFLAG(NOW)=0 GOTO 9080
9070 GOSUB 9190 'ADD TO TABLE
9080 S1=I1
9090 IF RUNTYPE<>2 GOTO 8280
9100 GOSUB 8770 'GET A WORD
9110 IF LEN.C=0 GOTO 9150
9120 IF ASC(C$)>64 GOTO 8310
9130 GOSUB 9190 'ADD TO TABLE
9140 GOTO 9100
9150 RETURN
9160 '
9170 '  ADD DATENAMES AND/OR LINE NUMBERS TO THEIR RESPECTIVE TABLES
9180 '
9190 IF RUNTYPE<>4 GOTO 9260
9200 X=NOW
9210 DATANAME$(X)=MID$(C$,1,LEN.C)
9220 NUMLINES=RESCNT
9230 LINETO=X-SINGLE.PREC!
9240 GOTO 9470
9250 '
9260 IF RUNTYPE<>2 GOTO 9370
9270 LINETO=VAL(MID$(C$,1,LEN.C)) - SINGLE.PREC!
9280 FOR X=1 TO DIMLINE
9290 IF LINENOS(X,1)=LINETO GOTO 9350
9300 IF LINENOS(X,1)=-32768! GOTO 9340
9310 NEXT X
9320 GOTO 9960
9330 '
9340 NUMLINES=X
9350 GOTO 9470
9360 '
9370 IF RUNTYPE<>3 GOTO 5470
9380 FOR X=1 TO DNMCNT
9390 IF DATANAME$(X)="" GOTO 9440
9400 IF DATANAME$(X)=MID$(C$,1,LEN.C) GOTO 9460
9410 NEXT X
9420 GOTO 9960
9430 '
9440 DATANAME$(X)=MID$(C$,1,LEN.C)
9450 NUMLINES=X
9460 LINETO=X-SINGLE.PREC!
9470 LINENOS(X,1)=LINETO
9480 LINENOS(X,3)=X
9490 Z=LINENOS(X,2)
9500 IF Z=1 AND ACTUAL.RUNTYPE=5 GOTO 9560
9510 IF LINENOS(X,4)=LINENO GOTO 9560
9520 LINENOS(X,4)=LINENO
9530 LINENOS(X,2)=LINENOS(X,2) + 1
9540 IF ACTUAL.RUNTYPE=5 GOTO 9560
9550 GOSUB 9580 'WRITE LINE NO FILE RECORD
9560 RETURN
9570 '
9580 GOSUB 9680 'CHECK LINE NO FILE STATUS
9590 LSET DSK.LINETO$=MKI$(LINETO)
9600 LSET DSK.LINENO$=MKI$(LINENO)
9610 NUM.RECS=NUM.RECS+1
9620 ON ERROR GOTO 10370
9630 IO.ADDR=1
9640 PUT #3,NUM.RECS
9650 ON ERROR GOTO 0
9660 RETURN
9670 '
9680 IF LINENOS.XRF.OPEN.STATUS=-1 THEN RETURN
9690 LINENOS.XRF.OPEN.STATUS=-1
9700 M$=""
9710 ON ERROR GOTO 9780
9720 LINENO.FILE$=LINEDRIVE$+"LINENOS.XRF"
9730 OPEN LINENO.FILE$ AS #3 LEN=4
9740 FIELD #3,2 AS DSK.LINETO$,2 AS DSK.LINENO$
9750 ON ERROR GOTO 0
9760 RETURN
9770 '
9780 GOSUB 5840 'GET TYPE ERR
9790 RESUME 9800
9800 ON ERROR GOTO 0
9810 LINENOS.XRF.OPEN.STATUS=0
9820 GOSUB 1940 'CLEAR 24-25
9830 LOCATE 25,1,1
9840 COLOR 15
9850 PRINT REASON$;" OPEN ON ";"LINENOS.XRF";" FAILED. ";M$;
9860 LOCATE 24,1
9870 PRINT "CORRECT PROBLEM AND PRESS ANY KEY TO CONTINUE";
9880 GOSUB 12610 'FLUSH BUFFERS
9890 KEYIN$=INKEY$
9900 IF KEYIN$="" GOTO 9890
9910 IF KEYIN$=CHR$(27) GOTO 17570
9920 GOSUB 1940 'CLEAR 24-25
9930 LOCATE ROW,COLUMN,0
9940 GOTO 9750
9950 '
9960 ERRNO=6
9970 GOTO 5470
9980 '
9990 '  SORT LINE NUMBER TABLE
10000 '
10010 PRINT "START - LINE NUMBER TABLE SORT : ";TIME$
10020 GOSUB 11780 'GET YOUR ATTN.
10030 ROW=CSRLIN
10040 COLUMN=POS(0)
10050 LOCATE 25,1,0
10060 PRINT STRING$(79," ");
10070 LOCATE 25,1,0
10080 PRINT "** SORTING";
10090 LAST=NUMLINES
10100 GAP=LAST\2
10110 WHILE GAP>0
10120 FOR I=GAP+1 TO LAST
10130 J=I-GAP
10140 WHILE J>0
10150 IF LINENOS(J,1)<=LINENOS(J+GAP,1) THEN J=0:GOTO 10200
10160 SWAP LINENOS(J,1),LINENOS(J+GAP,1)
10170 SWAP LINENOS(J,2),LINENOS(J+GAP,2)
10180 SWAP LINENOS(J,3),LINENOS(J+GAP,3)
10190 J=J-GAP
10200 WEND
10210 LOCATE 25,1,0
10220 PRINT "          ";
10230 LOCATE 25,1,0
10240 PRINT "** SORTING";
10250 NEXT
10260 GAP=GAP\2
10270 WEND
10280 LOCATE 25,1,0
10290 PRINT STRING$(79," ");
10300 LOCATE ROW,COLUMN,1
10310 PRINT
10320 PRINT "FINISH- LINE NUMBER TABLE SORT : ";TIME$
10330 GOSUB 11780 'GET YOUR ATTN.
10340 PRINT
10350 RETURN
10360 '
10370 ROW=CSRLIN
10380 COLUMN=POS(0)
10390 GOSUB 5840 'GET TYPE RR
10400 RESUME 10410
10410 GOSUB 1940 'CLEAR 24-25
10420 LOCATE 25,1,1
10430 COLOR 15
10440 PRINT "INPUT/OUTPUT ERROR ON FILE :";LINENOS.FILE$;" : ";M$;
10450 M$=" "
10460 LOCATE 24,1
10470 PRINT "CORRECT PROBLEM AND PRESS ANY KEY TO CONTINUE";
10480 GOSUB 12610 'FLUSH BUFFERS
10490 KEYIN$=INKEY$
10500 IF KEYIN$="" GOTO 10490
10510 IF KEYIN$=CHR$(27) GOTO 17570
10520 COLOR 7
10530 GOSUB 1940 'CLEAR 24-25
10540 LOCATE ROW,COLUMN,0
10550 IF IO.ADDR=1 GOTO 9640
10560 IF IO.ADDR=6 GOTO 6940
10570 PRINT "PROGRAM TRAP REACHED - RANDOM IO ROUTINES"
10580 STOP
10590 END
10600 '
10610 LPRINT.STRING$=CHR$(13)+CHR$(12)
10620 GOSUB 10790 'PRINT THE STRING
10630 LPRINT.STRING$="PROGRAM : "+DSN$+SPACE$(75)+DATE$+" @ "+TIME$
10640 GOSUB 10790
10650 LPRINT.STRING$=""
10660 GOSUB 10790
10670 LPRINT.STRING$=SPACE$(35)+"LINE NUMBER CROSS-REFERENCE"
10680 GOSUB 10790
10690 LPRINT.STRING$=""
10700 GOSUB 10790
10710 LPRINT.STRING$=" LINE"
10720 GOSUB 10790
10730 LPRINT.STRING$="NUMBER                -------REFERENCES------REFERENCES------REFERENCES------REFERENCES------"
10740 GOSUB 10790
10750 ON ERROR GOTO 0
10760 LINECNT=8
10770 RETURN
10780 '
10790 ON ERROR GOTO 10860
10800 LPRINT LPRINT.STRING$
10810 ON ERROR GOTO 0
10820 RETURN
10830 '
10840 '  ERROR HANDLING ROUTINE FOR THE PRINTER
10850 '
10860 IF ERR=24 THEN RESUME 10790
10870 IF ERR<>27 THEN 11000
10880 CLS
10890 BEEP
10900 BEEP
10910 PRINT
10920 PRINT "PRINTER NOT READY OR OUT OF PAPER"
10930 PRINT "READY THE PRINTER, AND PRESS ANY KEY TO CONTINUE"
10940 GOSUB 12610 'FLUSH BUFFERS
10950 KEYIN$=INKEY$
10960 IF KEYIN$="" GOTO 10950
10970 IF KEYIN$=CHR$(27) GOTO 17570
10980 RESUME 10790
10990 '
11000 PRINT
11010 PRINT "BASIC ERROR : ";ERR;" AT LINE NO. : ";ERL
11020 GOTO 17570
11030 '
11040 '  SORT DATANAME TABLE
11050 '
11060 IF RUNTYPE=4 GOTO 11400
11070 PRINT "START - DATA NAME TABLE SORT : ";TIME$
11080 GOSUB 11780 'GET YOUR ATTN.
11090 ROW=CSRLIN
11100 COLUMN=POS(0)
11110 LOCATE 25,1,0
11120 PRINT STRING$(79," ");
11130 LOCATE 25,1,0
11140 PRINT "** SORTING";
11150 LAST=NUMLINES
11160 GAP=LAST\2
11170 WHILE GAP>0
11180 FOR I=GAP+1 TO LAST
11190 J=I-GAP
11200 WHILE J>0
11210 IF DATANAME$(J)<=DATANAME$(J+GAP) THEN J=0:GOTO 11270
11220 SWAP DATANAME$(J),DATANAME$(J+GAP)
11230 SWAP LINENOS(J,1),LINENOS(J+GAP,1)
11240 SWAP LINENOS(J,2),LINENOS(J+GAP,2)
11250 SWAP LINENOS(J,3),LINENOS(J+GAP,3)
11260 J=J-GAP
11270 WEND
11280 LOCATE 25,1,0
11290 PRINT "          ";
11300 LOCATE 25,1,0
11310 PRINT "** SORTING";
11320 NEXT
11330 GAP=GAP\2
11340 WEND
11350 LOCATE 25,1,0
11360 PRINT STRING$(79," ");
11370 LOCATE ROW,COLUMN,1
11380 PRINT "FINISH- DATA NAME TABLE SORT : ";TIME$
11390 GOSUB 11780 'GET YOUR ATTN.
11400 RETURN
11410 '
11420 '   PRINT HEADINGS FOR THE DATANAME CROSS REFERENCE
11430 '
11440 LPRINT.STRING$=CHR$(13)+CHR$(12)
11450 GOSUB 10790 'PRINT THE STRING
11460 LPRINT.STRING$="PROGRAM : "+DSN$+SPACE$(75)+DATE$+" @ "+TIME$
11470 GOSUB 10790
11480 LPRINT.STRING$=""
11490 GOSUB 10790
11500 IF RUNTYPE=3 THEN LPRINT.STRING$=SPACE$(35)+"DATA NAME CROSS-REFERENCE":GOSUB 10790
11510 IF RUNTYPE=4 THEN LPRINT.STRING$=SPACE$(30)+"RESERVED WORD CROSS-REFERENCE":GOSUB 10790
11520 LPRINT.STRING$=""
11530 GOSUB 10790
11540 IF RUNTYPE=3 THEN LPRINT.STRING$=" DATA":GOSUB 10790
11550 IF RUNTYPE=4 THEN LPRINT.STRING$=" RESERVED":GOSUB 10790
11560 IF RUNTYPE=3 THEN LPRINT.STRING$=" NAME                 ------REFERENCES------REFERENCES------REFERENCES------REFERENCES------":GOSUB 10790
11570 IF RUNTYPE=4 THEN LPRINT.STRING$="   WORD               ------REFERENCES------REFERENCES------REFERENCES------REFERENCES------":GOSUB 10790
11580 ON ERROR GOTO 0
11590 LINECNT=8
11600 RETURN
11610 '
11620 '  PRINT THE LINE NUMBER THAT IS CURRENTLY PROCESSING
11630 '
11640 LOCATE 25,29,0
11650 PRINT MID$(CURLNUM$,1,LEN.CURLNUM);
11660 RETURN
11670 '
11680 '  SEE WHAT KIND OF ADAPTER IS ON THIS SYSTEM
11690 '
11700 DEF SEG=0
11710 IBMMONO=0
11720 IF (PEEK(&H410) AND &H30)=&H30 THEN IBMMONO=1
11730 CURSOR.STOP=7
11740 IF IBMMONO=1 THEN CURSOR.STOP=13
11750 LOCATE,,,0,CURSOR.STOP
11760 RETURN
11770 '
11780 FOR BEEP1=1 TO BEEPCNT
11790 BEEP
11800 FOR BEEP2=1 TO BEEPLOOP
11810 NEXT BEEP2
11820 NEXT BEEP1
11830 RETURN
11840 '
11850 COLOR 7,0
11860 CLS
11870 LOCATE 4,30
11880 PRINT "Software solutions by ";
11890 LOCATE 9,33
11900 PRINT "Soft-SHARE (tm)";
11910 LOCATE 14,15
11920 PRINT "Soft-SHARE , a limited user suppored concept similar to";
11930 LOCATE 15,15
11940 PRINT "FreeWare (c) in that a small contribution is asked but";
11950 LOCATE 16,15
11960 PRINT "not required, to support the authors efforts. If you ";
11970 LOCATE 17,15
11980 PRINT "find this Soft-SHARE product of value a $10 donation is";
11990 LOCATE 18,15
12000 PRINT "asked.. else you are asked to pass it on in its original";
12010 LOCATE 19,15
12020 PRINT "unmodified form. Send comments, updates , donations, or ";
12030 LOCATE 20,15
12040 PRINT "requests for compiled version (with prepaid mailer), to";
12050 LOCATE 22,15
12060 PRINT "  James Morgan, 1749 AMERICANA 23-G, ORLANDO FLA 32809";
12070 LOCATE 24,27:PRINT "(press any key to continue)";
12080 KEYIN$=INKEY$:IF KEYIN$="" GOTO 12080
12090 RETURN
12100 '
12110 LOCATE 22,20
12120 COLOR 0,7
12130 CLS
12140 COLOR 0,7
12150 PRINT "                       ******************************"
12160 PRINT "                       *   BASIC PROGRAM PROCESSOR  *"
12170 PRINT "                       ******************************"
12180 PRINT
12190 PRINT "                               By James Morgan
12200 PRINT
12210 PRINT "                 OPTION          DESCRIPTION"
12220 PRINT "                 ------     ---------------------------"
12230 PRINT
12240 PRINT "                   1        EXPAND ........BASIC PROGRAM"
12250 PRINT "                   2        LINE NUMBER ...CROSS REFERENCE"
12260 PRINT "                   3        DATA NAME .....CROSS REFERENCE"
12270 PRINT "                   4        RESERVED WORD .CROSS REFERENCE"
12280 PRINT "                   5        COMPRESS ......BASIC PROGRAM"
12290 PRINT "                   9        EXIT ..........PROGRAM"
12300 PRINT
12310 PRINT
12320 COLOR 31,0
12330 ROW=CSRLIN
12340 COLUMN=POS(0)
12350 GOSUB 12580
12360 GOSUB 11780 'GET YOUR ATTN
12370 GOSUB 12610 'FLUSH BUFFERS
12380 KEYIN$=INKEY$
12390 IF KEYIN$="" GOTO 12380
12400 IF LEN(KEYIN$)<>1 THEN BEEP:GOTO 12120
12410 COLOR 15,0
12420 PRINT KEYIN$
12430 IF VAL(KEYIN$)<1 THEN BEEP:GOTO 12120
12440 IF VAL(KEYIN$)=9 THEN COLOR 7,0:CLS:GOTO 17570
12450 IF VAL(KEYIN$)>5 THEN BEEP:GOTO 12120
12460 RUNTYPE=VAL(KEYIN$)
12470 ACTUAL.RUNTYPE=RUNTYPE
12480 IF ACTUAL.RUNTYPE=1 THEN GOSUB 12740
12490 IF ACTUAL.RUNTYPE=5 THEN GOSUB 12740:GOSUB 13050
12500 IF LPRNT THEN GOSUB 12680:GOTO 12530
12510 IF ACTUAL.RUNTYPE=1 OR ACTUAL.RUNTYPE=5 GOTO 12530
12520 GOSUB 12680 'INITIALIZE PRINTER
12530 IF RUNTYPE=5 THEN RUNTYPE=2
12540 ON ERROR GOTO 0
12550 COLOR 7,0
12560 RETURN
12570 '
12580 PRINT "           SELECT AND ENTER OPTION     ";
12590 RETURN
12600 '
12610 DEF SEG=0
12620 POKE 1050,PEEK(1052) ' FLUSH SYSTEM KEYBOARD BUFFER
12630 DEF SEG
12640 IF VER$="C" THEN RETURN
12650 POKE 106,0 ' FLUSH BASIC INTERNAL KEYBOARD BUFFER
12660 RETURN
12670 '
12680 WIDTH "LPT1:",132
12690 LPRINT.STRING$=CHR$(15)
12700 GOSUB 10790
12710 EJECT=-1
12720 RETURN
12730 '
12740 PRINT
12750 PRINT
12760 SROW=ROW
12770 SCOLUMN=COLUMN
12780 ROW=CSRLIN
12790 COLUMN=POS(0)
12800 LOCATE SROW,SCOLUMN
12810 COLOR 15,0
12820 GOSUB 12580
12830 COLOR 0,7
12840 LOCATE ROW,COLUMN,0
12850 PRINT STRING$(79," ");
12860 LOCATE ROW,COLUMN,1
12870 COLOR 15,0
12880 PRINT "DO YOU WANT ";
12890 IF ACTUAL.RUNTYPE=1 THEN PRINT "AN EXPANDED ";
12900 IF ACTUAL.RUNTYPE=5 THEN PRINT "A COMPRESSED ";
12910 PRINT "PROGRAM LISTING ALSO? (Y OR N) > ";
12920 GOSUB 12610 'FLUSH BUFFERS
12930 ANS$=INKEY$
12940 IF ANS$="" GOTO 12930
12950 IF LEN(ANS$)<>1 THEN BEEP:GOTO 12930
12960 IF ANS$=CHR$(27) GOTO 17570
12970 COLOR 15,0
12980 PRINT ANS$;
12990 COLOR 0,7
13000 IF ANS$="N" THEN RETURN
13010 IF ANS$<>"Y" THEN BEEP:GOTO 12840
13020 LPRNT=-1
13030 RETURN
13040 '
13050 LOCATE CSRLIN+2,1
13060 SROW=ROW
13070 SCOLUMN=COLUMN
13080 ROW=CSRLIN
13090 COLUMN=POS(0)
13100 LOCATE SROW,SCOLUMN
13110 COLOR 0,7
13120 LOCATE ROW,COLUMN,0
13130 PRINT STRING$(79," ");
13140 LOCATE ROW,COLUMN,1
13150 COLOR 15,0
13160 PRINT "DO YOU WANT TO REMOVE UNREFERENCED LINE NUMBERS : ";
13170 GOSUB 12610 'FLUSH BUFFERS
13180 ANS$=INKEY$
13190 IF ANS$="" GOTO 13180
13200 IF LEN(ANS$)<>1 THEN BEEP:GOTO 13180
13210 IF ANS$=CHR$(27) GOTO 17570
13220 COLOR 15,0
13230 PRINT ANS$;
13240 COLOR 0,7
13250 IF ANS$="N" THEN RETURN
13260 IF ANS$<>"Y" THEN BEEP:GOTO 13120
13270 REMOVE.UNREFERENCED.LINENOS=-1
13280 RETURN
13290 '
13300 ROW=CSRLIN
13310 COLUMN=POS(0)
13320 LOCATE ROW,COLUMN,0
13330 FOR I=1 TO 24 - ROW
13340 PRINT STRING$(79," ")
13350 NEXT
13360 GOSUB 1940 'CLEAR 24-25
13370 OUTDRIVE$=""
13380 LOCATE ROW,COLUMN,1
13390 BEEP
13400 PRINT
13410 PRINT "CREATING OUTPUT FILE : "+OUTFILE$+" WHILE "+REASON$
13420 PRINT
13430 PRINT "WHAT DRIVE IS THE FILE TO BE ON (PRESS ENTER FOR DEFAULT)"
13440 PRINT "DRIVE : ";
13450 GOSUB 12610
13460 OUTDRIVE$=INKEY$
13470 IF OUTDRIVE$="" GOTO 13460
13480 IF OUTDRIVE$=CHR$(27) GOTO 17570
13490 IF LEN(OUTDRIVE$)<>1 THEN BEEP:GOTO 13460
13500 IF OUTDRIVE$=CR$ THEN OUTDRIVE$="":GOTO 13570
13510 IF OUTDRIVE$<"A" THEN BEEP:GOTO 13460
13520 IF OUTDRIVE$>"Z" THEN BEEP:GOTO 13460
13530 PRINT OUTDRIVE$;
13540 OUTDRIVE$=OUTDRIVE$+":"
13550 GOTO 13570
13560 '
13570 ON ERROR GOTO 13620
13580 OPEN OUTDRIVE$+OUTFILE$ FOR OUTPUT AS #2
13590 ON ERROR GOTO 0
13600 RETURN
13610 '
13620 GOSUB 5840 'GET TYPE ERR
13630 RESUME 13640
13640 ON ERROR GOTO 0
13650 GOSUB 1940 'CLEAR 24-25
13660 LOCATE 25,1,1
13670 COLOR 15
13680 PRINT REASON$;" FILE OPEN ON ";OUTFILE$;" FAILED. ";M$;
13690 LOCATE 24,1
13700 PRINT "CORRECT PROBLEM AND PRESS ANY KEY TO CONTINUE";
13710 GOSUB 12610 'FLUSH BUFFERS
13720 KEYIN$=INKEY$
13730 IF KEYIN$="" GOTO 13720
13740 IF KEYIN$=CHR$(27) GOTO 17570
13750 GOSUB 1940 'CLEAR 24-25
13760 LOCATE ROW,COLUMN,0
13770 GOTO 13320
13780 '
13790 ROW=CSRLIN
13800 COLUMN=POS(0)
13810 LOCATE ROW,COLUMN,0
13820 FOR I=1 TO 24 - ROW
13830 PRINT STRING$(79," ")
13840 NEXT
13850 GOSUB 1940 'CLEAR 25-25
13860 LINEDRIVE$=""
13870 LOCATE ROW,COLUMN,1
13880 PRINT
13890 PRINT "CREATING OUTPUT FILE : "+"LINENOS.XRF"+" WHILE "+REASON$
13900 PRINT
13910 PRINT "WHAT DRIVE IS THE FILE TO BE ON (PRESS ENTER FOR DEFAULT)"
13920 PRINT "DRIVE : ";
13930 GOSUB 12610 'FLUSH BUFFERS
13940 LINEDRIVE$=INKEY$
13950 IF LINEDRIVE$="" GOTO 13940
13960 IF LINEDRIVE$=CHR$(27) GOTO 17570
13970 IF LEN(LINEDRIVE$)<>1 THEN BEEP:GOTO 13940
13980 IF LINEDRIVE$=CR$ THEN LINEDRIVE$="":GOTO 14030
13990 IF LINEDRIVE$<"A" THEN BEEP:GOTO 13940
14000 IF LINEDRIVE$>"Z" THEN BEEP:GOTO 13940
14010 PRINT LINEDRIVE$;
14020 LINEDRIVE$=LINEDRIVE$+":"
14030 ON ERROR GOTO 14100
14040 KILL LINEDRIVE$+"LINENOS.XRF"
14050 ON ERROR GOTO 0
14060 GOSUB 9680 'OPEN LINE NO FILE
14070 IF M$<>"" GOTO 13810
14080 RETURN
14090 '
14100 ERR.NO=ERR
14110 RESUME 14120
14120 ON ERROR GOTO 0
14130 IF ERR.NO=53 GOTO 14060
14140 GOSUB 1940 'CLEAR 24-25
14150 LOCATE 25,1
14160 PRINT "** ERROR ";ERR.NO;" ACCESSING ";"LINENOS.XRF";
14170 LOCATE 24,1
14180 PRINT "CORRECT PROBLEM AND PRESS ANY KEY TO CONTINUE";
14190 GOSUB 12610 'FLUSH BUFFERS
14200 KEYIN$=INKEY$
14210 IF KEYIN$="" GOTO 14200
14220 IF KEYIN$=CHR$(27) GOTO 17570
14230 LOCATE 24,1
14240 PRINT STRING$(79," ");
14250 GOSUB 1940 'CLEAR 24-25
14260 LOCATE ROW,COLUMN,1
14270 GOTO 14030
14280 '
14290 ' SET CAPSLOCK ON
14300 '
14310 DEF SEG=&H40
14320 POKE &H17,PEEK(&H17) OR 64
14330 DEF SEG
14340 RETURN
14350 '
14360 '*************************************************************************
14370 '*                                                                       *
14380 '*               LOGIC TO COMPRESS A BASIC PROGRAM                       *
14390 '*                                                                       *
14400 '*************************************************************************
14410 FREECNT=0
14420 FREE!=FRE("")
14430 MID$(S$,1)=STRING$(255," ")
14440 LEN.S=0
14450 X=1
14460 ON ERROR GOTO 0
14470 PHASE=2
14480 CLOSE
14490 TYPE.STORED.PGM=32
14500 OPEN OUTDRIVE$+OUTFILE$ FOR INPUT AS 1
14510 OUTFILE$="TEMPCOMP.BAS"
14520 REASON$="COMPRESSING PROGRAM"
14530 GOSUB 13300 'CREATE COMPRESSED FILE
14540 START$=TIME$
14550 LOCATE 25,1,0
14560 PRINT "PROCESSING LINE NUMBER =                ";
14570 IF EOF(1) GOTO 16670
14580 GOSUB 2460 'READ EXPANDED BASIC PROGRAM FILE
14590 L=LEN.B
14600 GOSUB 5300 'FIND END OF LINE
14610 E=BEND
14620 GOSUB 14670 'ISOLATE LINE NUMBER AND FIND START OF BASIC STATEMENT
14630 GOTO 15100
14640 '
14650 '  ISOLATE LINE NUMBER AND FIND START OF BASIC STATEMENT(S)
14660 '
14670 MID$(CURLNUM$,1)=STRING$(255," ")
14680 LEN.CURLNUM=0
14690 FOR I=1 TO E
14700 MID$(BYTE$,1,1)=MID$(B$,I,1)
14710 IF BYTE$>" " GOTO 14730
14720 NEXT I
14730 S=I
14740 MID$(P$,1)=STRING$(255," ")
14750 LEN.P=0
14760 FOR I=S TO E
14770 MID$(BYTE$,1,1)=MID$(B$,I,1)
14780 IF BYTE$<"0" GOTO 14830
14790 IF BYTE$>"9" GOTO 14830
14800 LEN.P=LEN.P+1
14810 MID$(P$,LEN.P,1)=BYTE$
14820 NEXT I
14830 IF I=E THEN ERRNO=1:GOTO 5470
14840 IF LEN.P<1 THEN ERRN0=1:GOTO 5470
14850 IF LEN.P>5 THEN ERRNO=1:GOTO 5470
14860 MID$(CURLNUM$,1)=MID$(P$,1,LEN.P)
14870 LEN.CURLNUM=LEN.P
14880 GOSUB 11640 'PRINT CURRENT LINE NO
14890 CURLINE!=VAL(MID$(CURLNUM$,1,LEN.CURLNUM))
14900 LINENO=(CURLINE! - 32767)
14910 S=I
14920 GOSUB 15030 'SEE IF LINE NO REFREENCED
14930 FOR I=S TO E
14940 MID$(BYTE$,1,1)=MID$(B$,I,1)
14950 IF BYTE$>" " GOTO 14980
14960 NEXT I
14970 IF I=E THEN ERRNO=2:GOTO 5470
14980 S=I
14990 MID$(P$,1)=MID$(B$,S)
15000 LEN.P=LEN.B-S+1
15010 RETURN
15020 '
15030 EQUAL.LINENOS=FALSE
15040 FOR X=X TO NUMLINES
15050 IF LINENO=LINENOS(X,1) THEN EQUAL.LINENOS=-1:RETURN
15060 IF LINENO<LINENOS(X,1) THEN RETURN
15070 NEXT X
15080 RETURN
15090 '
15100 ADD=0
15110 REMPOS=0
15120 IFPOS=0
15130 IF EQUAL.LINENOS GOTO 16740
15140 ADD=-1
15150 IF MID$(P$,1,1)="'" GOTO 14570
15160 IF MID$(P$,1,3)="REM" GOTO 15430
15170 IF MID$(P$,1,4)="DATA" GOTO 15510
15180 GOSUB 15960
15190 IF ADD=0 THEN GOSUB 15630 'WRITE COMPRESSED LINE
15200 IF LEN.S=0 THEN GOSUB 15320:GOTO 15290 'PREFIX STATEMENT WITH LINE NO
15210 IF LEN.S>252 THEN ADD=0:GOTO 15190
15220 TOTAL.LEN=LEN.S+LEN.P + 1
15230 IF TOTAL.LEN>253 THEN ADD=0:GOTO 15190
15240 LEN.S=LEN.S+1
15250 MID$(S$,LEN.S)=":"
15260 LEN.S=LEN.S+1
15270 MID$(S$,LEN.S)=MID$(P$,1,LEN.P)
15280 LEN.S=LEN.S+LEN.P-1
15290 IF IFPOS<>0 THEN GOSUB 15630 'WRITE COMPRESSED LINE
15300 GOTO 14570
15310 '
15320 IF REMOVE.UNREFERENCED.LINENOS=0 GOTO 15340
15330 IF EQUAL.LINENOS=0 GOTO 15360
15340 MID$(S$,1)=MID$(CURLNUM$,1,LEN.CURLNUM)
15350 LEN.S=LEN.CURLNUM
15360 LEN.S=LEN.S+1
15370 MID$(S$,LEN.S)=" "
15380 LEN.S=LEN.S+1
15390 MID$(S$,LEN.S)=MID$(P$,1,LEN.P)
15400 LEN.S=LEN.S+LEN.P-1
15410 RETURN
15420 '
15430 IF LEN.P<4 GOTO 14570
15440 IF MID$(P$,4,1)=" " GOTO 14570
15450 IF MID$(P$,4,1)="." GOTO 15180
15460 IF ASC(MID$(P$,4,1))<48 GOTO 14570
15470 IF ASC(MID$(P$,4,1))>90 GOTO 14570
15480 IF (ASC(MID$(P$,4,1))>57) AND (ASC(MID$(P$,4,1))<65) GOTO 14570
15490 GOTO 15180
15500 '
15510 IF LEN.P<5 GOTO 14570
15520 IF MID$(P$,5,1)=" " GOTO 15590
15530 IF MID$(P$,5,1)="." GOTO 15180
15540 IF ASC(MID$(P$,5,1))<48 GOTO 15590
15550 IF ASC(MID$(P$,5,1))>90 GOTO 15590
15560 IF (ASC(MID$(P$,5,1))>57) AND (ASC(MID$(P$,5,1))<65) GOTO 15590
15570 GOTO 15180
15580 '
15590 IFPOS=1
15600 ADD=0
15610 GOTO 15190
15620 '
15630 IF LEN.S=0 THEN RETURN
15640 GOSUB 15690 'WRITE COMPRESSED RECORD
15650 MID$(S$,1)=STRING$(255," ")
15660 LEN.S=0
15670 RETURN
15680 '
15690 ON ERROR GOTO 15750
15700 PRINT#2,MID$(S$,1,LEN.S)
15710 ON ERROR GOTO 0
15720 IF LPRNT THEN LPRINT MID$(S$,1,LEN.S)
15730 RETURN
15740 '
15750 ROW=CSRLIN
15760 COLUMN=POS(0)
15770 GOSUB 5840 'GET TYPE ERR
15780 RESUME 15790
15790 ON ERROR GOTO 0
15800 GOSUB 1940 'CLEAR 24-25
15810 LOCATE 25,1,1
15820 COLOR 15
15830 PRINT "COMPRESSED PROGRAM WRITE FAILED. ";M$;
15840 M$=" "
15850 LOCATE 24,1
15860 PRINT "CORRECT PROBLEM AND PRESS ANY KEY TO CONTINUE";
15870 GOSUB 12610 'FLUSH BUFFERS
15880 KEYIN$=INKEY$
15890 IF KEYIN$="" GOTO 15880
15900 IF KEYIN$=CHR$(27) GOTO 17570
15910 COLOR 7
15920 GOSUB 1940 'CLEAR 24-25
15930 LOCATE ROW,COLUMN,0
15940 GOTO 15690
15950 '
15960 I=1
15970 MID$(H$,1)=MID$(P$,1,LEN.P)
15980 LEN.H=LEN.P
15990 FOR I=I TO LEN.P
16000 IF MID$(P$,I,1)=QUOTE$ GOTO 16050
16010 IF MID$(P$,I,1)="'" GOTO 16160
16020 NEXT I
16030 GOTO 16300
16040 '
16050 MID$(H$,I,1)=" "
16060 I=I + 1
16070 FOR I=I TO LEN.P
16080 MID$(H$,I,1)=" "
16090 IF MID$(P$,I,1)=QUOTE$ THEN I=I + 1:GOTO 15990
16100 NEXT I
16110 PRINT
16120 PRINT "PROGRAM TRAP REACHED"
16130 STOP
16140 END
16150 '
16160 MID$(P$,1)=MID$(P$,1,I - 1)
16170 LEN.P=I-1
16180 L=LEN.P
16190 FOR I=L TO 1 STEP -1
16200 IF MID$(P$,I,1)<>" " GOTO 16250
16210 NEXT I
16220 ERRNO=3
16230 GOTO 5470
16240 '
16250 MID$(P$,1)=MID$(P$,1,I)
16260 LEN.P=I
16270 MID$(H$,1)=MID$(H$,1,I)
16280 LEN.H=I
16290 L=LEN.P
16300 GOSUB 16360 'REMOVE ANY UNNECESSARY CHARS. FROM STATEMENT
16310 IFPOS=INSTR(1,MID$(H$,1,LEN.H),"IF ")
16320 REMPOS=INSTR(1,MID$(H$,1,LEN.H),"REM ")
16330 IF REMPOS<>0 THEN GOSUB 16490
16340 RETURN
16350 '
16360 FOR I=1 TO LEN.H
16370 V=ASC(MID$(H$,I,1))
16380 IF V=46 GOTO 16430 '"."
16390 IF V<48 GOTO 16460 '"0"
16400 IF V>90 GOTO 16460 '"Z"
16410 IF V>64 GOTO 16430 '"@"
16420 IF V>57 GOTO 16460 '"9"
16430 NEXT I
16440 RETURN
16450 '
16460 MID$(H$,I,1)=" "
16470 GOTO 16430
16480 '
16490 MID$(P$,1)=MID$(P$,1,REMPOS - 1)
16500 LEN.P=REMPOS-1
16510 MID$(H$,1)=MID$(H$,1,REMPOS - 1)
16520 LEN.H=REMPOS-1
16530 L=LEN.P
16540 FOR I=L TO 1 STEP -1
16550 IF MID$(P$,I,1)<>" " THEN 16600
16560 NEXT I
16570 ERRNO=3
16580 GOTO 5470
16590 '
16600 MID$(P$,1)=MID$(P$,1,I)
16610 LEN.P=I
16620 MID$(H$,1)=MID$(H$,1,I)
16630 LEN.H=I
16640 L=LEN.P
16650 RETURN
16660 '
16670 GOSUB 15630 'SEE IF ANYTHING LEFT IN BUFFER
16680 FINISH$=TIME$
16690 PRINT
16700 PRINT "COMPRESS PROCESSING FINISHED AT : ";FINISH$
16710 PRINT "COMPRESS PROCESSING STARTED  AT : ";START$
16720 GOTO 17570
16730 '
16740 IF MID$(P$,1,1)="'" THEN IFPOS=1:GOTO 15190
16750 IF MID$(P$,1,3)="REM" GOTO 16790
16760 IF MID$(P$,1,4)="DATA" GOTO 16910
16770 GOTO 15180
16780 '
16790 IF LEN.P<4 GOTO 16870
16800 IF MID$(P$,4,1)="." GOTO 15180
16810 IF MID$(P$,4,1)=" " GOTO 16870
16820 IF ASC(MID$(P$,4,1))<48 GOTO 16870
16830 IF ASC(MID$(P$,4,1))>90 GOTO 16870
16840 IF (ASC(MID$(P$,4,1))>57) AND (ASC(MID$(P$,4,1))<65) GOTO 16870
16850 GOTO 15180
16860 '
16870 ADD=0
16880 IFPOS=1
16890 GOTO 15190
16900 '
16910 IF LEN.P<5 GOTO 16870
16920 IF MID$(P$,5,1)="." GOTO 15180
16930 IF MID$(P$,5,1)=" " GOTO 16870
16940 IF ASC(MID$(P$,5,1))<48 GOTO 16870
16950 IF ASC(MID$(P$,5,1))>90 GOTO 16870
16960 IF (ASC(MID$(P$,5,1))>57) AND (ASC(MID$(P$,5,1))<65) GOTO 16870
16970 GOTO 15180
16980 '
16990 I=1
17000 FOR I=I TO LEN.B
17010 MID$(BYTE$,1,1)=MID$(B$,I,1)
17020 IF BYTE$=QUOTE$ GOTO 17290
17030 IF BYTE$="'" THEN L=LEN.B:RETURN
17040 IF I>1 THEN IF BYTE$=":" AND MID$(B$,I-1,1)=":" THEN MID$(B$,I,1)=" "
17050 IF BYTE$<" " THEN MID$(B$,I,1)=" "
17060 IF BYTE$>CHR$(122) THEN MID$(B$,I,1)=" "
17070 IF (ACTUAL.RUNTYPE=5) OR (RUNTYPE=1) GOTO 17080 ELSE GOTO 17090
17080 IF BYTE$=" " GOTO 17380 'REMOVE EXTRANEOUS SPACES
17090 IF BYTE$>CHR$(96) THEN MID$(B$,I,1)=CHR$(ASC(BYTE$) AND 95)
17100 IF (BYTE$<>"D") AND (BYTE$<>"R") GOTO 17240
17110 IF BYTE$<>"R" GOTO 17190
17120 MID$(C$,1)=MID$(B$,I,4)
17130 LEN.C=LEN.B-I+1
17140 IF LEN.C>4 THEN LEN.C=4
17150 GOSUB 4970 'CHECK IF "REM"
17160 IF MID$(C$,1,LEN.C)=REM1$ THEN L=LEN.B:RETURN
17170 GOTO 17240
17180 '
17190 MID$(C$,1)=MID$(B$,I,5)
17200 LEN.C=LEN.B-I+1
17210 IF LEN.C>5 THEN LEN.C=5
17220 GOSUB 5120 'CHECK IF "DATA"
17230 IF MID$(C$,1,LEN.C)=DATA1$ THEN L=LEN.B:RETURN
17240 NEXT I
17250 '
17260 L=LEN.B
17270 RETURN
17280 '
17290 FOR I=I+1 TO LEN.B
17300 IF MID$(B$,I,1)=QUOTE$ THEN I=I+1:GOTO 17000
17310 NEXT I
17320 IF LEN.B>253 THEN ERRNO=5:GOTO 5470
17330 LEN.B=LEN.B+1 'ADD MISSING END QUOTE (")
17340 MID$(B$,LEN.B,1)=QUOTE$
17350 L=LEN.B
17360 RETURN
17370 '
17380 IF I=1 GOTO 17240
17390 IF I>=LEN.B THEN L=LEN.B:RETURN
17400 MID$(SB$,1)=MID$(B$,1,I)
17410 LEN.SB=I
17420 FOR J=I+1 TO LEN.B
17430 IF MID$(B$,J,1)<>" " GOTO 17460
17440 NEXT
17450 IF J>=LEN.B GOTO 17260
17460 MID$(BYTE$,1,1)=MID$(SB$,LEN.SB-1,1)
17470 IF INSTR("=:,(<>*/\;^",BYTE$)<>0 THEN MID$(SB$,1)=LEFT$(SB$,LEN.SB-1):LEN.SB=LEN.SB-1
17480 MID$(BYTE$,1,1)=MID$(B$,J,1)
17490 IF MID$(SB$,LEN.SB,1)=" " THEN IF INSTR("=:,)<>*/\^;",BYTE$)<>0 THEN MID$(SB$,1)=LEFT$(SB$,LEN.SB-1):LEN.SB=LEN.SB-1
17500 I=LEN.SB+1
17510 MID$(SB$,LEN.SB+1)=MID$(B$,J)
17520 LEN.SB=LEN.SB+(LEN.B-J+1)
17530 MID$(B$,1)=LEFT$(SB$,LEN.SB)
17540 LEN.B=LEN.SB
17550 GOTO 17000
17560 '
17570 ON ERROR GOTO 0
17580 CLOSE
17590 PRINT
17600 BEEP
17610 KEYIN$=""
17620 PRINT "PRESS ENTER TO EXIT PROGRAM"
17630 GOSUB 12610 'FLUSH BUFFERS
17640 KEYIN$=INKEY$
17650 IF KEYIN$="" GOTO 17640
17660 IF LEN(KEYIN$)<>1 GOTO 17640
17670 IF KEYIN$<>CR$ GOTO 17640
17680 CLEAR
17690 COLOR 7,0
17700 CLS
17710 END
17720 '*
17730 '*                  PROCESS TOKENIZED BASIC PROGRAM
17740 '*
17750 READY.TO.RETURN=0
17760 ON ENTRY.POINT GOTO 17820,17870,18050,18070,17970
17770 OPEN DSN$ AS #1 LEN=2
17780 FIELD #1,2 AS PGM.BYTE$
17790 GOSUB 19730 'GET BEGINNING LINE ATTR.
17800 IF TYPE.READ=1 GOTO 17870
17810 '
17820 GOSUB 19730
17830 B=A
17840 GOSUB 19730
17850 NEXT.OFFSET!=B+(TWO.FIFTY.SIX!*A) 'BYPASS NEXT LINE POINTER ATTR X'00' BYTE
17860 '
17870 IF NEXT.OFFSET!=0 GOTO 19660
17880 GOSUB 19730 'GET THE LINE NUMBER FOR THIS STATEMENT
17890 B=A
17900 GOSUB 19730
17910 LINE.NO!=B+(TWO.FIFTY.SIX!*A)
17920 MID$(T$,1)=STRING$(255," ")
17930 LEN.T=0
17940 GOSUB 20180
17950 IF READY.TO.RETURN THEN ENTRY.POINT=5:RETURN
17960 '
17970 MID$(T$,1)=STR$(LINE.NO!)
17980 MID$(T$,1)=MID$(T$,2)
17990 LEN.T=LEN(STR$(LINE.NO!))-1
18000 GOSUB 20180
18010 IF READY.TO.RETURN THEN ENTRY.POINT=3:RETURN
18020 '
18030 '***** IDENTIFY TOKENS *****
18040 '
18050 GOSUB 19730
18060 '
18070 IF A<128 GOTO 18560
18080 '*****   KEYWORDS      *****
18090 IF A=143 GOTO 18360 'REMARK ?
18100 IF A=132 GOTO 18520 ' DATA?
18110 IF A<253 THEN X=252:ELSE X=A:GOSUB 19730
18120 ON X-251 GOTO 18150,18190,18230,18270
18130 GOTO 20340
18140 '
18150 MID$(T$,1)=CK$(A-128)
18160 LEN.T=LEN(CK$(A-128))
18170 GOTO 18310 'CASSETTE KEYWORD
18180 '
18190 MID$(T$,1)=DF$(A-128)
18200 LEN.T=LEN(DF$(A-128))
18210 GOTO 18310 'DISK FUNCTION
18220 '
18230 MID$(T$,1)=DK$(A-128)
18240 LEN.T=LEN(DK$(A-128))
18250 GOTO 18310 'DISK KEYWORD
18260 '
18270 MID$(T$,1)=CF$(A-128)
18280 LEN.T=LEN(CF$(A-128))
18290 GOTO 18310 'CASSETTE FUNCTION
18300 '
18310 GOSUB 20180
18320 IF READY.TO.RETURN THEN ENTRY.POINT=3:RETURN
18330 GOTO 18050
18340 '
18350 '*****   REMARK  *****
18360 MID$(T$,1)="'"
18370 LEN.T=1
18380 GOSUB 19730
18390 IF A<>217 THEN GOSUB 20290
18400 GOSUB 19730
18410 IF TYPE.READ=1 THEN IF EOL=0 THEN GOSUB 20290:GOTO 18400:ELSE GOTO 18470
18420 IF A<>0 THEN GOSUB 20290:GOTO 18400
18430 GOSUB 20180
18440 IF READY.TO.RETURN THEN ENTRY.POINT=1:RETURN
18450 GOTO 17820
18460 '
18470 GOSUB 20180
18480 IF READY.TO.RETURN THEN ENTRY.POINT=2:RETURN
18490 GOTO 17870
18500 '
18510 '*****   DATA    *****
18520 MID$(T$,1)="DATA"
18530 LEN.T=4
18540 GOTO 18310
18550 '
18560 IF A<65 OR A>90 GOTO 18660
18570 '****    NAME    *****
18580 MID$(T$,1)=MID$(C$,1,LEN.C)
18590 LEN.T=LEN.C
18600 GOSUB 19730
18610 IF (A>64 AND A<91) OR (A>47 AND A<58) OR A=46 OR A=33 OR A=35 OR A=36 OR A=37 THEN GOSUB 20290:GOTO 18600
18620 GOSUB 20180
18630 IF READY.TO.RETURN THEN ENTRY.POINT=4:RETURN
18640 GOTO 18070
18650 '
18660 IF A<>14 GOTO 18760
18670 '***** LINE NUMBER *****
18680 GOSUB 19730
18690 B=A
18700 GOSUB 19730
18710 MID$(T$,1)=STR$(B+(TWO.FIFTY.SIX!*A))
18720 MID$(T$,1)=MID$(T$,2)
18730 LEN.T=LEN(STR$(B+(TWO.FIFTY.SIX!*A)))-1
18740 GOTO 18310
18750 '
18760 IF A<>34 GOTO 18930
18770 '***** LITERAL CONSTANT *****
18780 MID$(T$,1)=MID$(C$,1,LEN.C)
18790 LEN.T=LEN.C
18800 GOSUB 19730
18810 IF TYPE.READ=1 THEN IF EOL=-1 GOTO 18850:ELSE GOSUB 20290:IF A<>34 GOTO 18800:ELSE GOTO 18850
18820 IF A=0 THEN GOTO 18430
18830 GOSUB 20290
18840 IF A<>34 GOTO 18800
18850 GOSUB 20180
18860 IF TYPE.READ=1 AND EOL=-1 GOTO 18900
18870 IF READY.TO.RETURN THEN ENTRY.POINT=3:RETURN
18880 GOTO 18050
18890 '
18900 IF READY.TO.RETURN THEN ENTRY.POINT=2:RETURN
18910 GOTO 17870
18920 '
18930 IF A<17 OR A>26 GOTO 19000
18940 '***** 1 DECIMAL DIGIT CONSTANT *****
18950 MID$(T$,1)=STR$(A-17)
18960 MID$(T$,1)=MID$(T$,2)
18970 LEN.T=LEN(STR$(A-17))-1
18980 GOTO 18310
18990 '
19000 IF A<>15 GOTO 19080
19010 '***** 1 BYTE INTERGER CONSTANT *****
19020 GOSUB 19730
19030 MID$(T$,1)=STR$(A)
19040 MID$(T$,1)=MID$(T$,2)
19050 LEN.T=LEN(STR$(A))-1
19060 GOTO 18310
19070 '
19080 IF A<>28 GOTO 19180
19090 '***** 2 BYTE SIGNED INTERGER *****
19100 GOSUB 19730
19110 B=A
19120 GOSUB 19730
19130 MID$(T$,1)=STR$(B+(TWO.FIFTY.SIX!*A))+"%"
19140 MID$(T$,1)=MID$(T$,2)
19150 LEN.T=LEN(STR$(B+(TWO.FIFTY.SIX!*A)))
19160 GOTO 18310
19170 '
19180 IF A<>29 GOTO 19320
19190 '***** 4 BYTE FLOATING POINT *****
19200 MID$(T$,1)=STRING$(255," ")
19210 LEN.T=0
19220 X=VARPTR(N!)
19230 FOR I=0 TO 3
19240 GOSUB 19730
19250 POKE X+I,A
19260 NEXT
19270 MID$(T$,1)=STR$(N!)+"!"
19280 MID$(T$,1)=MID$(T$,2)
19290 LEN.T=LEN(STR$(N!))
19300 GOTO 18310
19310 '
19320 IF A<>31 GOTO 19460
19330 '***** 8 BYTE FLOATING POINT *****
19340 MID$(T$,1)=STRING$(255," ")
19350 LEN.T=0
19360 X=VARPTR(N#)
19370 FOR I=0 TO 7
19380 GOSUB 19730
19390 POKE X+I,A
19400 NEXT
19410 MID$(T$,1)=STR$(N#)+"#"
19420 MID$(T$,1)=MID$(T$,2)
19430 LEN.T=LEN(STR$(N#))
19440 GOTO 18310
19450 '
19460 IF A<>11 AND A<>12 GOTO 19570
19470 '***** 2 BYTE HEX/OCTAL INTERGER *****
19480 A.TYPE=A
19490 GOSUB 19730
19500 B=A
19510 GOSUB 19730
19520 C!=B+(A*TWO.FIFTY.SIX!)
19530 IF A.TYPE=12 THEN MID$(T$,1)="&H"+HEX$(C!) ELSE MID$(T$,1)="&O"+OCT$(C!)
19540 IF A.TYPE=12 THEN LEN.T=2+LEN(HEX$(C!)) ELSE LEN.T=2+LEN(OCT$(C!))
19550 GOTO 18310
19560 '
19570 IF (A>43 AND A<60) OR A=32 OR A=35 OR A=40 OR A=41 OR A=91 OR A=93 THEN MID$(T$,1)=MID$(C$,1,LEN.C):LEN.T=LEN.C:GOTO 18310
19580 IF A>0 THEN MID$(T$,1)=MID$(C$,1,LEN.C):LEN.T=LEN.C:GOTO 18310
19590 IF TYPE.READ=1 AND EOL=-1 GOTO 17870
19600 IF A=0 GOTO 17820
19610 '***** OTHER *****
19620 IF A>96 AND A<122 THEN GOTO 20340 'LOWER CASE LETTERS ARE IMPOSSIBLE
19630 IF A<11 OR A=13 OR A=15 OR A=16 OR A=30 THEN GOTO 20340 'IMPOSSIBLE
19640 GOTO 20340 'WASN'T AN ASCII VALUE
19650 '
19660 MID$(T$,1)=STRING$(255," ")
19670 LEN.T=0
19680 GOSUB 20180
19690 CLOSE#1
19700 READY.TO.RETURN=255
19710 RETURN
19720 '
19730 IF TYPE.READ=1 GOTO 19770
19740 GOSUB 20070
19750 RETURN
19760 '
19770 EOL=0
19780 IF FIRST.TIME=0 GOTO 19810
19790 IF CURRENT.OFFSET!<>NEXT.OFFSET! GOTO 19970
19800 CURRENT.OFFSET!=NEXT.OFFSET!
19810 GOSUB 20070
19820 IF FIRST.TIME=0 AND A=255 GOTO 19840
19830 IF A<>0 GOTO 20010
19840 GOSUB 20070
19850 B=A
19860 GOSUB 20070
19870 NEXT.OFFSET!=B+(TWO.FIFTY.SIX!*A)
19880 PREVIOUS.OFFSET!=NEXT.OFFSET!
19890 CURRENT.OFFSET!=CURRENT.OFFSET!+3
19900 MID$(C$,1)=CHR$(0)
19910 LEN.C=1
19920 A=0
19930 EOL=-1
19940 FIRST.TIME=-1
19950 RETURN
19960 '
19970 GOSUB 20070
19980 CURRENT.OFFSET!=CURRENT.OFFSET!+1
19990 RETURN
20000 '
20010 CLOSE
20020 PRINT
20030 PRINT "DID NOT FIND EXPECTED HEX '00' NEW LINE DELIMITER"
20040 GOTO 20340
20050 '
20060 '
20070 IF BYTE.PTR<>0 GOTO 20100
20080 BYTE.PTR=1
20090 GET #1
20100 MID$(C$,1)=MID$(PGM.BYTE$,BYTE.PTR,1)
20110 LEN.C=1
20120 A=ASC(C$)
20130 BYTE.PTR=BYTE.PTR+1
20140 IF BYTE.PTR>2 THEN BYTE.PTR=0
20150 TOTAL.BYTES.READ!=TOTAL.BYTES.READ!+1
20160 RETURN
20170 '
20180 IF LEN.T=0 GOTO 20260
20190 IF LEN.S=0 GOTO 20230
20200 IF (MID$(T$,1,1)=":") AND (MID$(S$,LEN.S,1)=":") THEN MID$(T$,1)=STRING$(255," "):LEN.T=0:RETURN
20210 IF (MID$(T$,1,LEN.T)="ELSE") THEN IF (MID$(S$,LEN.S,1)=":") AND (MID$(S$,LEN.S-1,1)=" ") THEN MID$(S$,1)=LEFT$(S$,LEN.S-1):LEN.S=LEN.S-1
20220 IF LEN.S+LEN.T>253 THEN PRINT:PRINT MID$(S$,1,LEN.S):PRINT MID$(T$,1,LEN.T):PRINT "THE PRECEEDING TWO LINE WOULD BE GREATER THAN 253 CHARACTERS":PRINT "THIS CAN OCCUR ONLY IF TOKENIZED LINE EXPANDED INCORRECTLY":CLOSE:GOTO 20340
20230 LEN.S=LEN.S+1
20240 MID$(S$,LEN.S)=MID$(T$,1,LEN.T)
20250 LEN.S=LEN.S+LEN.T-1
20260 IF LEN.T=0 THEN IF LEN.S>0 THEN MID$(B$,1)=MID$(S$,1,LEN.S):LEN.B=LEN.S:LEN.S=0:MID$(S$,1)=STRING$(255," "):READY.TO.RETURN=-1
20270 RETURN
20280 '
20290 LEN.T=LEN.T+1
20300 MID$(T$,LEN.T)=MID$(C$,1,LEN.C)
20310 LEN.T=LEN.T+LEN.C-1
20320 RETURN
20330 '
20340 READY.TO.RETURN=0
20350 RETURN
20360 '
20370 TYPE.READ=0
20380 READY.TO.RETURN=0
20390 OPEN DSN$ AS #1 LEN=1
20400 FIELD #1,1 AS PGM.BYTE$
20410 GET #1,1
20420 IF EOF(1) THEN CLOSE:GOTO 20340
20430 TYPE.STORED.PGM=ASC(PGM.BYTE$)
20440 IF TYPE.STORED.PGM=253 THEN CLS:CLOSE:PRINT:PRINT "PROGRAM NOT STORED AS TEXT OR TOKENIZED, UNPROTECTED, BASIC FILE":GOTO 20340
20450 IF TYPE.STORED.PGM<>254 THEN CLOSE:READY.TO.RETURN=-1:RETURN
20460 GET #1,2
20470 IF EOF(1) THEN CLOSE:GOTO 20340
20480 A=ASC(PGM.BYTE$)
20490 GET #1,3
20500 IF EOF(1) THEN CLOSE:GOTO 20340
20510 FIRST.OFFSET!=A+(TWO.FIFTY.SIX!*ASC(PGM.BYTE$))
20520 IF FIRST.OFFSET!=0 THEN CLOSE:GOTO 20340
20530 HIGH.OFFSET.BYTE$=PGM.BYTE$
20540 PASS=1
20550 REC.CNT=6
20560 FOR REC.CNT=REC.CNT TO 300
20570 GET #1,REC.CNT
20580 IF EOF(1) GOTO 20610
20590 IF PGM.BYTE$=HIGH.OFFSET.BYTE$ GOTO 20690
20600 NEXT REC.CNT
20610 IF PASS=2 GOTO 20820
20620 PASS=2
20630 IF ASC(HIGH.OFFSET.BYTE$)=255 GOTO 20820
20640 B=ASC(HIGH.OFFSET.BYTE$)
20650 B=B+1
20660 HIGH.OFFSET.BYTE$=CHR$(B)
20670 GOTO 20550
20680 '
20690 GET #1,REC.CNT-2
20700 IF ASC(PGM.BYTE$)<>0 THEN REC.CNT=REC.CNT+1:GOTO 20560
20710 GET #1,REC.CNT-1
20720 A=ASC(PGM.BYTE$)
20730 NEXT.OFFSET!=A+(TWO.FIFTY.SIX!*ASC(HIGH.OFFSET.BYTE$))
20740 IF NEXT.OFFSET!<=FIRST.OFFSET! THEN REC.CNT=REC.CNT+1:GOTO 20560
20750 INITIAL.OFFSET!=FIRST.OFFSET!-(REC.CNT-3)
20760 CURRENT.OFFSET!=INITIAL.OFFSET!
20770 NEXT.OFFSET!=FIRST.OFFSET!
20780 PREVIOUS.OFFSET!=INITIAL.OFFSET!
20790 TYPE.READ=1
20800 GOTO 20830
20810 '
20820 TYPE.READ=0
20830 CLOSE
20840 READY.TO.RETURN=-1
20850 RETURN
20860 '
20870 DATA "END"
20880 DATA "FOR"
20890 DATA "NEXT"
20900 DATA "DATA"
20910 DATA "INPUT"
20920 DATA "DIM"
20930 DATA "READ"
20940 DATA "LET"
20950 DATA "GOTO"
20960 DATA "RUN"
20970 DATA "IF"
20980 DATA "RESTORE"
20990 DATA "GOSUB"
21000 DATA "RETURN"
21010 DATA "REM"
21020 DATA "STOP"
21030 DATA "PRINT"
21040 DATA "CLEAR"
21050 DATA "LIST"
21060 DATA "NEW"
21070 DATA "ON"
21080 DATA "WAIT"
21090 DATA "DEF"
21100 DATA "POKE"
21110 DATA "CONT"
21120 DATA "?"
21130 DATA "?"
21140 DATA "OUT"
21150 DATA "LPRINT"
21160 DATA "LLIST"
21170 DATA "?"
21180 DATA "WIDTH"
21190 DATA "ELSE"
21200 DATA "TRON"
21210 DATA "TROFF"
21220 DATA "SWAP"
21230 DATA "ERASE"
21240 DATA "EDIT"
21250 DATA "ERROR"
21260 DATA "RESUME"
21270 DATA "DELETE"
21280 DATA "AUTO"
21290 DATA "RENUM"
21300 DATA "DEFSTR"
21310 DATA "DEFINT"
21320 DATA "DEFSNG"
21330 DATA "DEFDBL"
21340 DATA "LINE"
21350 DATA "WHILE"
21360 DATA "WEND"
21370 DATA "CALL"
21380 DATA "?"
21390 DATA "?"
21400 DATA "?"
21410 DATA "WRITE"
21420 DATA "OPTION"
21430 DATA "RANDOMIZE"
21440 DATA "OPEN"
21450 DATA "CLOSE"
21460 DATA "LOAD"
21470 DATA "MERGE"
21480 DATA "SAVE"
21490 DATA "COLOR"
21500 DATA "CLS"
21510 DATA "MOTOR"
21520 DATA "BSAVE"
21530 DATA "BLOAD"
21540 DATA "SOUND"
21550 DATA "BEEP"
21560 DATA "PSET"
21570 DATA "PRESET"
21580 DATA "SCREEN"
21590 DATA "KEY"
21600 DATA "LOCATE"
21610 DATA "?"
21620 DATA "TO"
21630 DATA "THEN"
21640 DATA "TAB("
21650 DATA "STEP"
21660 DATA "USR"
21670 DATA "FN"
21680 DATA "SPC("
21690 DATA "NOT"
21700 DATA "ERL"
21710 DATA "ERR"
21720 DATA "STRING$"
21730 DATA "USING"
21740 DATA "INSTR"
21750 DATA "'"
21760 DATA "VARPTR"
21770 DATA "CSRLIN"
21780 DATA "POINT"
21790 DATA "OFF"
21800 DATA "INKEY$"
21810 DATA "?"
21820 DATA "?"
21830 DATA "?"
21840 DATA "?"
21850 DATA "?"
21860 DATA "?"
21870 DATA "?"
21880 DATA ">"
21890 DATA "="
21900 DATA "<"
21910 DATA "+"
21920 DATA "-"
21930 DATA "*"
21940 DATA "/"
21950 DATA "^"
21960 DATA "AND"
21970 DATA "OR"
21980 DATA "XOR"
21990 DATA "EQV"
22000 DATA "IMP"
22010 DATA "MOD"
22020 DATA "\"
22030 DATA "?"
22040 DATA "?"
22050 DATA "?"
22060 DATA "?"
22070 DATA "?"
22080 DATA "?"
22090 DATA "?"
22100 DATA "?"
22110 DATA "LEFT$"
22120 DATA "RIGHT$"
22130 DATA "MID$"
22140 DATA "SGN"
22150 DATA "INT"
22160 DATA "ABS"
22170 DATA "SQR"
22180 DATA "RND"
22190 DATA "SIN"
22200 DATA "LOG"
22210 DATA "EXP"
22220 DATA "COS"
22230 DATA "TAN"
22240 DATA "ATN"
22250 DATA "FRE"
22260 DATA "INP"
22270 DATA "POS"
22280 DATA "LEN"
22290 DATA "STR$"
22300 DATA "VAL"
22310 DATA "ASC"
22320 DATA "CHR$"
22330 DATA "PEEK"
22340 DATA "SPACE$"
22350 DATA "OCT$"
22360 DATA "HEX$"
22370 DATA "LPOS"
22380 DATA "CINT"
22390 DATA "CSGN"
22400 DATA "CDBL"
22410 DATA "FIX"
22420 DATA "PEN"
22430 DATA "STICK"
22440 DATA "STRIG"
22450 DATA "EOF"
22460 DATA "LOC"
22470 DATA "LOF"
22480 DATA "FILES"
22490 DATA "FIELD"
22500 DATA "SYSTEM"
22510 DATA "NAME"
22520 DATA "LSET"
22530 DATA "RSET"
22540 DATA "KILL"
22550 DATA "PUT"
22560 DATA "GET"
22570 DATA "RESET"
22580 DATA "COMMON"
22590 DATA "CHAIN"
22600 DATA "DATE$"
22610 DATA "TIME$"
22620 DATA "PAINT"
22630 DATA "COM"
22640 DATA "CIRCLE"
22650 DATA "DRAW"
22660 DATA "PLAY"
22670 DATA "TIMER"
22680 DATA "IOCTL"
22690 DATA "MKDIR"
22700 DATA "SHELL"
22710 DATA "VIEW"
22720 DATA "PMAP"
22730 DATA "ERDEV"
22740 DATA "CHDIR"
22750 DATA "RMDIR"
22760 DATA "ENVIRON"
22770 DATA "WINDOW"
22780 DATA "CVI"
22790 DATA "CVS"
22800 DATA "CVD"
22810 DATA "MKI$"
22820 DATA "MKS$"
22830 DATA "MKD$"
22840 '
22850 DATA 158
22860 DATA "ABS",2
22870 DATA "AND",1
22880 DATA "ASC",3
22890 DATA "ATN",2
22900 DATA "AUTO",9
22910 DATA "BEEP",1
22920 DATA "BLOAD",9
22930 DATA "BSAVE",9
22940 DATA "CALL",4
22950 DATA "CDBL",1
22960 DATA "CHAIN",4
22970 DATA "CHR",3
22980 DATA "CINT",1
22990 DATA "CIRCLE",1
23000 DATA "CLEAR",1
23010 DATA "CLOSE",1
23020 DATA "CLS",1
23030 DATA "COLOR",1
23040 DATA "COM",1
23050 DATA "COMMON",4
23060 DATA "CONT",9
23070 DATA "COS",2
23080 DATA "CSNG",1
23090 DATA "CSRLIN",1
23100 DATA "CVD",1
23110 DATA "CVI",1
23120 DATA "CVS",1
23130 DATA "DATA",0
23140 DATA "DATE",1
23150 DATA "DEF",1
23160 DATA "DEFDBL",1
23170 DATA "DEFINT",1
23180 DATA "DEFSNG",1
23190 DATA "DEFSTR",1
23200 DATA "DELETE",9
23210 DATA "DIM",1
23220 DATA "DRAW",1
23230 DATA "EDIT",9
23240 DATA "ELSE",0
23250 DATA "END",1
23260 DATA "ENVIRON",1
23270 DATA "EOF",1
23280 DATA "EQV",1
23290 DATA "ERASE",1
23300 DATA "ERDEV",1
23310 DATA "ERL",1
23320 DATA "ERR",1
23330 DATA "ERROR",1
23340 DATA "EXP",2
23350 DATA "FIELD",1
23360 DATA "FILES",9
23370 DATA "FIX",1
23380 DATA "FOR",4
23390 DATA "FRE",1
23400 DATA "GET",1
23410 DATA "GOSUB",4
23420 DATA "GOTO",4
23430 DATA "HEX",3
23440 DATA "IF",1
23450 DATA "IMP",1
23460 DATA "INKEY",1
23470 DATA "INP",1
23480 DATA "INPUT",1
23490 DATA "INSTR",4
23500 DATA "INT",2
23510 DATA "IOCTL",1
23520 DATA "KEY",1
23530 DATA "KILL",9
23540 DATA "LEFT",3
23550 DATA "LEN",3
23560 DATA "LET",0
23570 DATA "LINE",1
23580 DATA "LIST",9
23590 DATA "LLIST",9
23600 DATA "LOAD",9
23610 DATA "LOC",1
23620 DATA "LOCATE",1
23630 DATA "LOF",1
23640 DATA "LOG",2
23650 DATA "LPOS",1
23660 DATA "LPRINT",1
23670 DATA "LSET",1
23680 DATA "MERGE",9
23690 DATA "MID",3
23700 DATA "MKD",3
23710 DATA "MKI",3
23720 DATA "MKS",3
23730 DATA "MOD",2
23740 DATA "MOTOR",1
23750 DATA "NAME",9
23760 DATA "NEW",9
23770 DATA "NEXT",4
23780 DATA "NOT",0
23790 DATA "OCT",3
23800 DATA "OFF",1
23810 DATA "ON",0
23820 DATA "OPEN",1
23830 DATA "OPTION",1
23840 DATA "OR",0
23850 DATA "OUT",1
23860 DATA "PAINT",1
23870 DATA "PEEK",1
23880 DATA "PEN",1
23890 DATA "PLAY",1
23900 DATA "PMAP",1
23910 DATA "POINT",1
23920 DATA "POKE",1
23930 DATA "POS",1
23940 DATA "PRESET",1
23950 DATA "PRINT",1
23960 DATA "PSET",1
23970 DATA "PUT",1
23980 DATA "RANDOMIZE",2
23990 DATA "READ",1
24000 DATA "REM",1
24010 DATA "RENUM",9
24020 DATA "RESET",1
24030 DATA "RESTORE",1
24040 DATA "RESUME",4
24050 DATA "RETURN",4
24060 DATA "RIGHT",3
24070 DATA "RND",2
24080 DATA "RSET",1
24090 DATA "RUN",4
24100 DATA "SAVE",9
24110 DATA "SCREEN",1
24120 DATA "SGN",2
24130 DATA "SHELL",1
24140 DATA "SIN",2
24150 DATA "SOUND",1
24160 DATA "SPACE",3
24170 DATA "SPC",3
24180 DATA "SQR",2
24190 DATA "STEP",0
24200 DATA "STICK",1
24210 DATA "STOP",1
24220 DATA "STR",3
24230 DATA "STRIG",1
24240 DATA "STRING",1
24250 DATA "SWAP",1
24260 DATA "SYSTEM",9
24270 DATA "TAB",0
24280 DATA "TAN",2
24290 DATA "THEN",0
24300 DATA "TIME",1
24310 DATA "TO",0
24320 DATA "TROFF",1
24330 DATA "TRON",1
24340 DATA "USING",1
24350 DATA "USR",4
24360 DATA "VAL",3
24370 DATA "VARPTR",1
24380 DATA "WAIT",1
24390 DATA "WEND",1
24400 DATA "WHILE",1
24410 DATA "WIDTH",1
24420 DATA "WRITE",1
24430 DATA "XOR",0
24440 END
```

{% comment %}samples_end{% endcomment %}

### Directory of PC-SIG Library Disk #0381

     Volume in drive A has no label
     Directory of A:\

    BASICAID BAS     66469   5-31-84  10:49p
    BASICAID DOC     12716   5-31-84  11:32p
    BASICAID EXE     65786   5-19-84   9:12p
    BRENTBAS EXE     32464   2-09-85   8:56a
    BRENTBAS UM      23317   2-09-85  10:24a
    FILES381 TXT       845   7-08-85   2:40p
    TBASIC   ASM     46816   6-28-82   9:04p
    TBASIC   COM      2795   6-28-82   9:06p
    TBASIC   DOC     25344   7-27-81
            9 file(s)     276552 bytes
                           43008 bytes free
